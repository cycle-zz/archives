<html>
	<head>
		<title>SPARK: Stream Processing Abstraction and Rendering Toolkit</title>
		<link HREF="style.css" REL="stylesheet" TYPE="text/css">
	</head>
	<body>
		<div width="100%" height="40px" class="banner">
			Spark API Documentation
		</div>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>SpProcedural.cpp</h1><a href="SpProcedural_8cpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">// #############################################################################</span>
00002 <span class="comment">// # Operators.h - Basic procedural functions for pixel manipulation</span>
00003 <span class="comment">// #</span>
00004 <span class="comment">// # Created    : May 2004</span>
00005 <span class="comment">// # Copyright  : (C) 2004 by Derek Gerstmann</span>
00006 <span class="comment">// # Email      : dgerstma@acm.org</span>
00007 <span class="comment">// #</span>
00008 <span class="comment">// #############################################################################</span>
00009 
00010 <span class="comment">// =============================================================================</span>
00011 <span class="comment">//</span>
00012 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
00013 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
00014 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
00015 <span class="comment">//  (at your option) any later version.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">// =============================================================================</span>
00018 
00019 <span class="preprocessor">#include "<a class="code" href="SpProcedural_8h.html">SpProcedural.h</a>"</span>
00020 <span class="preprocessor">#include "<a class="code" href="SpMaths_8h.html">SpMaths.h</a>"</span>
00021 
00022 <span class="comment">// ---------------------------------------------------------------------------</span>
00023 
00024 <span class="keyword">using</span> <span class="keyword">namespace </span>Spark;
00025 
00026 <span class="comment">// ---------------------------------------------------------------------------</span>
00027 <span class="keyword">template</span>&lt; <span class="keyword">class</span> Real &gt;
<a name="l00028"></a><a class="code" href="namespaceSpark.html#a72">00028</a> Real <a class="code" href="namespaceSpark.html#a72">Spark::Spline</a>(Real fX, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiKnots, Real *apkKnots, <span class="keyword">const</span> Real afBasis[4][4])
00029 {
00030     <span class="keywordtype">int</span> iSpan;
00031     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiSpanCount = uiKnots - 3;
00032 
00033     <span class="keywordflow">if</span> (uiSpanCount &lt; 1)
00034         <span class="keywordflow">return</span> 0;
00035 
00036     <span class="comment">// Find the appropriate 4-point span of the Spline.</span>
00037     fX = <a class="code" href="namespaceSpark.html#a42">Clamp</a>(fX, (Real)0.0, (Real)1.0) * uiSpanCount;
00038     iSpan = (<span class="keywordtype">int</span>) fX;
00039 
00040     <span class="keywordflow">if</span> (iSpan &gt;= (<span class="keywordtype">int</span>)uiKnots - 3)
00041         iSpan = (<span class="keywordtype">int</span>)uiKnots - 3;
00042 
00043     fX -= iSpan;
00044     apkKnots += iSpan;
00045 
00046     <span class="comment">// evaluate with appropriate basis</span>
00047     <span class="keywordflow">return</span> CubicSpan(fX, apkKnots, afBasis);
00048 }
00049 <span class="comment">// ---------------------------------------------------------------------------</span>
00050 <span class="keyword">template</span>&lt; <span class="keyword">class</span> Real &gt;
<a name="l00051"></a><a class="code" href="namespaceSpark.html#a73">00051</a> Real <a class="code" href="namespaceSpark.html#a73">Spark::CellNoise</a>( Real fX, Real fY, Real fZ )
00052 {
00053     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iX = (<span class="keywordtype">int</span>)<a class="code" href="namespaceSpark.html#a44">Floor</a>(fX);
00054     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iY = (<span class="keywordtype">int</span>)<a class="code" href="namespaceSpark.html#a44">Floor</a>(fY);
00055     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iZ = (<span class="keywordtype">int</span>)<a class="code" href="namespaceSpark.html#a44">Floor</a>(fZ);
00056     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iHash = <a class="code" href="namespaceSpark.html#a93">Hash</a>(iX, iY, iZ);
00057     <span class="keywordflow">return</span> <a class="code" href="namespaceSpark.html#a92">r</a>(iHash);
00058 }
00059 <span class="comment">// ---------------------------------------------------------------------------</span>
00060 <span class="keyword">template</span>&lt; <span class="keyword">class</span> Real &gt;
<a name="l00061"></a><a class="code" href="namespaceSpark.html#a74">00061</a> Real <a class="code" href="namespaceSpark.html#a74">Spark::GradientNoise</a>(Real fX, Real fY, Real fZ)
00062 {
00063     <span class="keywordtype">int</span> iX, iY, iZ;
00064     Real fX0, fX1, fY0, fY1, fZ0, fZ1;
00065     Real fWX, fWY, fWZ;
00066     Real fVX0, fVX1, fVY0, fVY1, fVZ0, fVZ1;
00067 
00068     iX = (<span class="keywordtype">int</span>)<a class="code" href="namespaceSpark.html#a44">Floor</a>(fX);
00069     fX0 = fX - iX;
00070     fX1 = fX0 - 1;
00071     fWX = <a class="code" href="namespaceSpark.html#a98">Cubic</a>(fX0);
00072 
00073     iY = (<span class="keywordtype">int</span>)<a class="code" href="namespaceSpark.html#a44">Floor</a>(fY);
00074     fY0 = fY - iY;
00075     fY1 = fY0 - 1;
00076     fWY = <a class="code" href="namespaceSpark.html#a98">Cubic</a>(fY0);
00077 
00078     iZ = (<span class="keywordtype">int</span>)<a class="code" href="namespaceSpark.html#a44">Floor</a>(fZ);
00079     fZ0 = fZ - iZ;
00080     fZ1 = fZ0 - 1;
00081     fWZ = <a class="code" href="namespaceSpark.html#a98">Cubic</a>(fZ0);
00082 
00083     fVX0 = <a class="code" href="namespaceSpark.html#a95">Gradient</a>(iX, iY, iZ, fX0, fY0, fZ0);
00084     fVX1 = <a class="code" href="namespaceSpark.html#a95">Gradient</a>(iX + 1, iY, iZ, fX1, fY0, fZ0);
00085 
00086     fVY0 = <a class="code" href="namespaceSpark.html#a100">Lerp</a>(fWX, fVX0, fVX1);
00087 
00088     fVX0 = <a class="code" href="namespaceSpark.html#a95">Gradient</a>(iX, iY + 1, iZ, fX0, fY1, fZ0);
00089     fVX1 = <a class="code" href="namespaceSpark.html#a95">Gradient</a>(iX + 1, iY + 1, iZ, fX1, fY1, fZ0);
00090 
00091     fVY1 = <a class="code" href="namespaceSpark.html#a100">Lerp</a>(fWX, fVX0, fVX1);
00092     fVZ0 = <a class="code" href="namespaceSpark.html#a100">Lerp</a>(fWY, fVY0, fVY1);
00093 
00094     fVX0 = <a class="code" href="namespaceSpark.html#a95">Gradient</a>(iX, iY, iZ + 1, fX0, fY0, fZ1);
00095     fVX1 = <a class="code" href="namespaceSpark.html#a95">Gradient</a>(iX + 1, iY, iZ + 1, fX1, fY0, fZ1);
00096 
00097     fVY0 = <a class="code" href="namespaceSpark.html#a100">Lerp</a>(fWX, fVX0, fVX1);
00098 
00099     fVX0 = <a class="code" href="namespaceSpark.html#a95">Gradient</a>(iX, iY + 1, iZ + 1, fX0, fY1, fZ1);
00100     fVX1 = <a class="code" href="namespaceSpark.html#a95">Gradient</a>(iX + 1, iY + 1, iZ + 1, fX1, fY1, fZ1);
00101 
00102     fVY1 = <a class="code" href="namespaceSpark.html#a100">Lerp</a>(fWX, fVX0, fVX1);
00103     fVZ1 = <a class="code" href="namespaceSpark.html#a100">Lerp</a>(fWY, fVY0, fVY1);
00104 
00105     <span class="keywordflow">return</span> 1.0f - 2.0f * <a class="code" href="namespaceSpark.html#a100">Lerp</a>(fWZ, fVZ0, fVZ1);
00106     <span class="comment">//return Lerp(fWZ, fVZ0, fVZ1);</span>
00107 
00108 }
00109 <span class="comment">//******************************************************************************</span>
00110 <span class="keyword">template</span>&lt; <span class="keyword">class</span> Real &gt;
<a name="l00111"></a><a class="code" href="namespaceSpark.html#a75">00111</a> Real <a class="code" href="namespaceSpark.html#a75">Spark::ValueNoise</a>(Real fX, Real fY, Real fZ, <span class="keyword">const</span> Real afBasis[4][4])
00112 {
00113     <span class="keywordtype">int</span> i, j, k;
00114     <span class="keywordtype">int</span> iX, iY, iZ;
00115     Real fRX, fRY, fRZ;
00116     Real afKnotsX[4], afKnotsY[4], afKnotsZ[4];
00117 
00118     iX = (<span class="keywordtype">int</span>)floor(fX);
00119     fRX = fX - iX;
00120 
00121     iY = (<span class="keywordtype">int</span>)floor(fY);
00122     fRY = fY - iY;
00123 
00124     iZ = (<span class="keywordtype">int</span>)floor(fZ);
00125     fRZ = fZ - iZ;
00126 
00127     <span class="keywordflow">for</span> (k = -1; k &lt;= 2; k++)
00128     {
00129         <span class="keywordflow">for</span> (j = -1; j &lt;= 2; j++)
00130         {
00131             <span class="keywordflow">for</span> (i = -1; i &lt;= 2; i++)
00132             {
00133                 afKnotsX[i + 1] = <a class="code" href="namespaceSpark.html#a94">Lattice</a>(iX + i, iY + j, iZ + k);
00134             }
00135             afKnotsY[j + 1] = <a class="code" href="namespaceSpark.html#a72">Spline</a>(fRX, 4, afKnotsX, afBasis);
00136         }
00137         afKnotsZ[k + 1] = <a class="code" href="namespaceSpark.html#a72">Spline</a>(fRY, 4, afKnotsY, afBasis);
00138     }
00139     <span class="keywordflow">return</span> <a class="code" href="namespaceSpark.html#a72">Spline</a>(fRZ, 4, afKnotsZ, afBasis);
00140 }
00141 <span class="comment">// ---------------------------------------------------------------------------</span>
00142 <span class="keyword">template</span>&lt; <span class="keyword">class</span> Real &gt;
<a name="l00143"></a><a class="code" href="namespaceSpark.html#a76">00143</a> Real <a class="code" href="namespaceSpark.html#a76">Spark::FractionalBrownianMotion</a>(
00144     Real fX, Real fY, Real fZ, Real fIncrement,
00145     Real fLacunarity, Real fOctaves)
00146 {
00147     <span class="comment">// static variables for caching spectral weights</span>
00148     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiMaxOctaves = 32;
00149     <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00150     <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00151     <span class="keyword">static</span> Real fPrevLacunarity = 0;
00152 
00153     <span class="comment">// precompute and store spectral weights</span>
00154     <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00155     {
00156         <span class="comment">//  compute weight for each frequency</span>
00157         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; uiMaxOctaves; i++ )
00158             afExponents[i] = pow( fLacunarity, (Real)i * -fIncrement );
00159 
00160         bInitialized = <span class="keyword">true</span>;
00161         fPrevLacunarity = fLacunarity;
00162     }
00163 
00164     <span class="comment">// create the fractional brownian motion</span>
00165     Real fSum = 0;
00166     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
00167     <span class="keywordflow">for</span>(i = 0;  i &lt; fOctaves;  i++)
00168     {
00169         fSum += (Real)(afExponents[i] * <a class="code" href="namespaceSpark.html#a74">GradientNoise</a>(fX, fY, fZ));
00170 
00171         <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00172         fX *= fLacunarity;
00173         fY *= fLacunarity;
00174         fZ *= fLacunarity;
00175     }
00176 
00177     <span class="comment">// take care of remainder in "octaves"</span>
00178     Real fRemainder = fOctaves - (<span class="keywordtype">int</span>)fOctaves;
00179     <span class="keywordflow">if</span> ( fRemainder )
00180     {
00181         <span class="comment">// "i" and spatial freq. are preset in loop above</span>
00182         fSum += (Real)(fRemainder * afExponents[i] * <a class="code" href="namespaceSpark.html#a74">GradientNoise</a>(fX, fY, fZ));
00183     }
00184     <span class="keywordflow">return</span> fSum;
00185 }
00186 <span class="comment">// ---------------------------------------------------------------------------</span>
00187 <span class="keyword">template</span>&lt; <span class="keyword">class</span> Real &gt;
<a name="l00188"></a><a class="code" href="namespaceSpark.html#a83">00188</a> Real <a class="code" href="namespaceSpark.html#a83">Spark::FilteredFBM</a>(
00189     Real fX, Real fY, Real fZ,
00190     Real fFilterWidth,
00191     Real fIncrement,
00192     Real fLacunarity,
00193     Real fOctaves)
00194 {
00195     <span class="comment">// static variables for caching spectral weights</span>
00196     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiMaxOctaves = 32;
00197     <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00198     <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00199     <span class="keyword">static</span> Real fPrevLacunarity = 0;
00200 
00201     <span class="comment">// precompute and store spectral weights</span>
00202     <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00203     {
00204         <span class="comment">//  compute weight for each frequency</span>
00205         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; uiMaxOctaves; i++ )
00206             afExponents[i] = pow( fLacunarity, (Real)i * -fIncrement );
00207 
00208         bInitialized = <span class="keyword">true</span>;
00209         fPrevLacunarity = fLacunarity;
00210     }
00211 
00212     <span class="comment">// create the fractional brownian motion</span>
00213     Real fSum = 0;
00214     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
00215     <span class="keywordflow">for</span>(i = 0;  i &lt; fOctaves;  i++)
00216     {
00217         fSum += (Real)(afExponents[i] * <a class="code" href="namespaceSpark.html#a111">FilteredGradientNoise</a>(fX, fY, fZ, fFilterWidth));
00218 
00219         <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00220         fX *= fLacunarity;
00221         fY *= fLacunarity;
00222         fZ *= fLacunarity;
00223 
00224         fFilterWidth *= fLacunarity;
00225     }
00226 
00227     <span class="comment">// take care of remainder in "octaves"</span>
00228     Real fRemainder = fOctaves - (<span class="keywordtype">int</span>)fOctaves;
00229     <span class="keywordflow">if</span> ( fRemainder )
00230     {
00231         <span class="comment">// "i" and spatial freq. are preset in loop above</span>
00232         fSum += (Real)(fRemainder * afExponents[i] * <a class="code" href="namespaceSpark.html#a111">FilteredGradientNoise</a>(fX, fY, fZ, fFilterWidth));
00233     }
00234     <span class="keywordflow">return</span> fSum;
00235 }
00236 <span class="comment">// ---------------------------------------------------------------------------</span>
00237 <span class="keyword">template</span>&lt; <span class="keyword">class</span> Real &gt;
<a name="l00238"></a><a class="code" href="namespaceSpark.html#a77">00238</a> Real <a class="code" href="namespaceSpark.html#a77">Spark::Turbulence</a>(
00239     Real fX, Real fY, Real fZ,
00240     Real fIncrement,
00241     Real fLacunarity,
00242     Real fOctaves)
00243 {
00244     <span class="comment">// static variables for caching spectral weights</span>
00245     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiMaxOctaves = 32;
00246     <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00247     <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00248     <span class="keyword">static</span> Real fPrevLacunarity = 0;
00249 
00250     <span class="comment">// precompute and store spectral weights</span>
00251     <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00252     {
00253         <span class="comment">//  compute weight for each frequency</span>
00254         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; uiMaxOctaves; i++ )
00255             afExponents[i] = pow( fLacunarity, (Real)i * -fIncrement );
00256 
00257         bInitialized = <span class="keyword">true</span>;
00258         fPrevLacunarity = fLacunarity;
00259     }
00260 
00261     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
00262     Real fTemp, fValue, fRemainder;
00263 
00264     fValue = 0.0;
00265     fTemp = 0.0;
00266 
00267     <span class="comment">// inner loop of spectral construction, where the fractal is built</span>
00268     <span class="keywordflow">for</span> (i = 0; i &lt; fOctaves; i++)
00269     {
00270         <span class="comment">// calculate the signal contribution</span>
00271         fTemp = (Real)(<a class="code" href="namespaceSpark.html#a74">GradientNoise</a>(fX, fY, fZ) * afExponents[i]);
00272 
00273         <span class="comment">// accumulate the result</span>
00274         fValue += <a class="code" href="namespaceSpark.html#a40">Abs</a>(fTemp);
00275 
00276         <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00277         fX *= fLacunarity;
00278         fY *= fLacunarity;
00279         fZ *= fLacunarity;
00280     }
00281 
00282     <span class="comment">// take care of remainder in "octaves"</span>
00283     fRemainder = fOctaves - (<span class="keywordtype">int</span>)fOctaves;
00284     <span class="keywordflow">if</span> ( fRemainder )
00285     {
00286         <span class="comment">// "i" and spatial freq. are preset in loop above</span>
00287         fTemp = (Real)(fRemainder * <a class="code" href="namespaceSpark.html#a74">GradientNoise</a>(fX, fY, fZ) * afExponents[i]);
00288 
00289         <span class="comment">// accumulate the result</span>
00290         fValue += <a class="code" href="namespaceSpark.html#a40">Abs</a>(fTemp);
00291     }
00292     <span class="keywordflow">return</span>( fValue );
00293 }
00294 <span class="comment">// ---------------------------------------------------------------------------</span>
00295 <span class="keyword">template</span>&lt; <span class="keyword">class</span> Real &gt;
<a name="l00296"></a><a class="code" href="namespaceSpark.html#a82">00296</a> Real <a class="code" href="namespaceSpark.html#a82">Spark::FilteredTurbulence</a>(
00297     Real fX, Real fY, Real fZ,
00298     Real fFilterWidth,
00299     Real fIncrement,
00300     Real fLacunarity,
00301     Real fOctaves)
00302 {
00303     <span class="comment">// static variables for caching spectral weights</span>
00304     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiMaxOctaves = 32;
00305     <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00306     <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00307     <span class="keyword">static</span> Real fPrevLacunarity = 0;
00308 
00309     <span class="comment">// precompute and store spectral weights</span>
00310     <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00311     {
00312         <span class="comment">//  compute weight for each frequency</span>
00313         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; uiMaxOctaves; i++ )
00314             afExponents[i] = pow( fLacunarity, (Real)i * -fIncrement );
00315 
00316         bInitialized = <span class="keyword">true</span>;
00317         fPrevLacunarity = fLacunarity;
00318     }
00319 
00320     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
00321     Real fTemp, fValue, fRemainder;
00322 
00323     fValue = 0.0;
00324     fTemp = 0.0;
00325 
00326     <span class="comment">// inner loop of spectral construction, where the fractal is built</span>
00327     <span class="keywordflow">for</span> (i = 0; i &lt; fOctaves; i++)
00328     {
00329         <span class="comment">// calculate the signal contribution</span>
00330         fTemp = (Real)(<a class="code" href="namespaceSpark.html#a111">FilteredGradientNoise</a>(fX, fY, fZ, fFilterWidth) * afExponents[i]);
00331 
00332         <span class="comment">// accumulate the result</span>
00333         fValue += <a class="code" href="namespaceSpark.html#a106">FilteredAbs</a>(fTemp, fFilterWidth);
00334 
00335         <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00336         fX *= fLacunarity;
00337         fY *= fLacunarity;
00338         fZ *= fLacunarity;
00339         fFilterWidth *= fLacunarity;
00340     }
00341 
00342     <span class="comment">// take care of remainder in "octaves"</span>
00343     fRemainder = fOctaves - (<span class="keywordtype">int</span>)fOctaves;
00344     <span class="keywordflow">if</span> ( fRemainder )
00345     {
00346         <span class="comment">// "i" and spatial freq. are preset in loop above</span>
00347         fValue += (Real)(fRemainder * <a class="code" href="namespaceSpark.html#a111">FilteredGradientNoise</a>(fX, fY, fZ, fFilterWidth) * afExponents[i]);
00348 
00349         <span class="comment">// accumulate the result</span>
00350         fValue += <a class="code" href="namespaceSpark.html#a106">FilteredAbs</a>(fTemp, fFilterWidth);
00351     }
00352     <span class="keywordflow">return</span>( fValue );
00353 }
00354 <span class="comment">// ---------------------------------------------------------------------------</span>
00355 <span class="keyword">template</span>&lt; <span class="keyword">class</span> Real &gt;
<a name="l00356"></a><a class="code" href="namespaceSpark.html#a78">00356</a> Real <a class="code" href="namespaceSpark.html#a78">Spark::MonoFractal</a>(
00357     Real fX, Real fY, Real fZ,
00358     Real fIncrement,
00359     Real fLacunarity,
00360     Real fOctaves)
00361 {
00362     <span class="comment">// static variables for caching spectral weights</span>
00363     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiMaxOctaves = 32;
00364     <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00365     <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00366     <span class="keyword">static</span> Real fPrevLacunarity = 0;
00367 
00368     <span class="comment">// precompute and store spectral weights</span>
00369     <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00370     {
00371         <span class="comment">//  compute weight for each frequency</span>
00372         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; uiMaxOctaves; i++ )
00373             afExponents[i] = pow( fLacunarity, (Real)i * -fIncrement );
00374 
00375         bInitialized = <span class="keyword">true</span>;
00376         fPrevLacunarity = fLacunarity;
00377     }
00378 
00379 
00380     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
00381     Real fValue, fRemainder;
00382     fValue = 0.0;
00383 
00384     <span class="comment">// inner loop of spectral construction, where the fractal is built</span>
00385     <span class="keywordflow">for</span> ( i = 0; i &lt; fOctaves; i++ )
00386     {
00387         <span class="comment">// evaluate the basis function to create the spectrum</span>
00388         fValue += (Real)(<a class="code" href="namespaceSpark.html#a74">GradientNoise</a>(fX, fY, fZ) * afExponents[i]);
00389 
00390         <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00391         fX *= fLacunarity;
00392         fY *= fLacunarity;
00393         fZ *= fLacunarity;
00394     }
00395 
00396     <span class="comment">// take care of remainder in "octaves"</span>
00397     fRemainder = fOctaves - (<span class="keywordtype">int</span>)fOctaves;
00398     <span class="keywordflow">if</span> ( fRemainder )
00399     {
00400         <span class="comment">// "i" and spatial freq. are preset in loop above</span>
00401         fValue += (Real)(fRemainder * <a class="code" href="namespaceSpark.html#a74">GradientNoise</a>(fX, fY, fZ) * afExponents[i]);
00402     }
00403     <span class="keywordflow">return</span>( fValue );
00404 }
00405 <span class="comment">// ---------------------------------------------------------------------------</span>
00406 <span class="keyword">template</span>&lt; <span class="keyword">class</span> Real &gt;
<a name="l00407"></a><a class="code" href="namespaceSpark.html#a79">00407</a> Real <a class="code" href="namespaceSpark.html#a79">Spark::MultiFractal</a>(
00408     Real fX, Real fY, Real fZ,
00409     Real fIncrement,
00410     Real fLacunarity,
00411     Real fOctaves)
00412 {
00413     <span class="comment">// static variables for caching spectral weights</span>
00414     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiMaxOctaves = 32;
00415     <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00416     <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00417     <span class="keyword">static</span> Real fPrevLacunarity = 0;
00418 
00419     <span class="comment">// precompute and store spectral weights</span>
00420     <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00421     {
00422         <span class="comment">//  compute weight for each frequency</span>
00423         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; uiMaxOctaves; i++ )
00424             afExponents[i] = pow( fLacunarity, (Real)i * -fIncrement );
00425 
00426         bInitialized = <span class="keyword">true</span>;
00427         fPrevLacunarity = fLacunarity;
00428     }
00429 
00430     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
00431     Real fValue, fRemainder;
00432     fValue = 1.0;
00433 
00434     <span class="comment">// inner loop of spectral construction, where the fractal is built</span>
00435     <span class="keywordflow">for</span> ( i = 0; i &lt; fOctaves; i++ )
00436     {
00437         <span class="comment">// evaluate the basis function to create the spectrum</span>
00438         fValue *= (Real)(afExponents[i] * <a class="code" href="namespaceSpark.html#a74">GradientNoise</a>(fX, fY, fZ) + 1.0f);
00439 
00440         <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00441         fX *= fLacunarity;
00442         fY *= fLacunarity;
00443         fZ *= fLacunarity;
00444     }
00445 
00446     <span class="comment">// take care of remainder in "octaves"</span>
00447     fRemainder = fOctaves - (<span class="keywordtype">int</span>)fOctaves;
00448     <span class="keywordflow">if</span> ( fRemainder )
00449     {
00450         fValue *= (Real)(fRemainder * afExponents[i] * <a class="code" href="namespaceSpark.html#a74">GradientNoise</a>(fX, fY, fZ) + 1.0f);
00451     }
00452     <span class="keywordflow">return</span>( fValue );
00453 }
00454 <span class="comment">// ---------------------------------------------------------------------------</span>
00455 <span class="keyword">template</span>&lt; <span class="keyword">class</span> Real &gt;
<a name="l00456"></a><a class="code" href="namespaceSpark.html#a80">00456</a> Real <a class="code" href="namespaceSpark.html#a80">Spark::HybridMultiFractal</a>(
00457     Real fX, Real fY, Real fZ,
00458     Real fIncrement,
00459     Real fLacunarity,
00460     Real fOffset,
00461     Real fGain,
00462     Real fOctaves)
00463 {
00464     <span class="comment">// static variables for caching spectral weights</span>
00465     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiMaxOctaves = 32;
00466     <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00467     <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00468     <span class="keyword">static</span> Real fPrevLacunarity = 0;
00469 
00470     <span class="comment">// precompute and store spectral weights</span>
00471     <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00472     {
00473         <span class="comment">//  compute weight for each frequency</span>
00474         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; uiMaxOctaves; i++ )
00475             afExponents[i] = pow( fLacunarity, (Real)i * -fIncrement );
00476 
00477         bInitialized = <span class="keyword">true</span>;
00478         fPrevLacunarity = fLacunarity;
00479     }
00480 
00481     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
00482 
00483     <span class="comment">// get signal for first octave</span>
00484     Real fSignal = <a class="code" href="namespaceSpark.html#a74">GradientNoise</a>(fX, fY, fZ);
00485 
00486     <span class="comment">// assign initial values</span>
00487     Real fResult = fSignal;
00488     Real fWeight = fGain * fSignal;
00489 
00490     <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00491     fX *= fLacunarity;
00492     fY *= fLacunarity;
00493     fZ *= fLacunarity;
00494 
00495     <span class="comment">// inner loop of spectral construction, where the fractal is built</span>
00496     <span class="keywordflow">for</span> ( i = 0; i &lt; fOctaves; i++ )
00497     {
00498         <span class="comment">// weight successive contributions by previous signal, clamp [0.0,1.0]</span>
00499         <span class="keywordflow">if</span>(fWeight &gt; 1.0f)
00500             fWeight = 1.0f;
00501 
00502         <span class="comment">// invert and translate (note that "offset" should be ~= 1.0)</span>
00503         fSignal = (Real)((<a class="code" href="namespaceSpark.html#a74">GradientNoise</a>(fX, fY, fZ) + fOffset) * afExponents[i]);
00504 
00505         <span class="comment">// weight the contribution</span>
00506         fResult += fSignal * fWeight;
00507 
00508         <span class="comment">// square the signal, to increase "sharpness" of ridges</span>
00509         fWeight *= fGain * fSignal;
00510 
00511         <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00512         fX *= fLacunarity;
00513         fY *= fLacunarity;
00514         fZ *= fLacunarity;
00515     }
00516 
00517     <span class="comment">// take care of remainder in "octaves"</span>
00518     Real fRemainder = fOctaves - (<span class="keywordtype">int</span>)fOctaves;
00519     <span class="keywordflow">if</span> ( fRemainder )
00520     {
00521         fResult *= (Real)(fRemainder * afExponents[i] * <a class="code" href="namespaceSpark.html#a74">GradientNoise</a>(fX, fY, fZ));
00522     }
00523     <span class="keywordflow">return</span> fResult;
00524 }
00525 <span class="comment">// ---------------------------------------------------------------------------</span>
00526 <span class="keyword">template</span>&lt; <span class="keyword">class</span> Real &gt;
<a name="l00527"></a><a class="code" href="namespaceSpark.html#a81">00527</a> Real <a class="code" href="namespaceSpark.html#a81">Spark::RidgedMultiFractal</a>(
00528     Real fX, Real fY, Real fZ,
00529     Real fIncrement,
00530     Real fLacunarity,
00531     Real fThreshold,
00532     Real fOffset,
00533     Real fOctaves)
00534 {
00535     <span class="comment">// static variables for caching spectral weights</span>
00536     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiMaxOctaves = 32;
00537     <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00538     <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00539     <span class="keyword">static</span> Real fPrevLacunarity = 0;
00540 
00541     <span class="comment">// precompute and store spectral weights</span>
00542     <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00543     {
00544         <span class="comment">//  compute weight for each frequency</span>
00545         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; uiMaxOctaves; i++ )
00546             afExponents[i] = pow( fLacunarity, (Real)i * -fIncrement );
00547 
00548         bInitialized = <span class="keyword">true</span>;
00549         fPrevLacunarity = fLacunarity;
00550     }
00551 
00552     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
00553 
00554     <span class="comment">// get absolute value of signal for first octave (this creates the ridges)</span>
00555     Real fSignal = <a class="code" href="namespaceSpark.html#a40">Abs</a>( <a class="code" href="namespaceSpark.html#a74">GradientNoise</a>(fX, fY, fZ) );
00556 
00557     <span class="comment">// invert and translate (note that "offset" should be ~= 1.0)</span>
00558     fSignal = fOffset - fSignal;
00559 
00560     <span class="comment">// square the signal, to increase "sharpness" of ridges</span>
00561     fSignal *= fSignal;
00562 
00563     <span class="comment">// assign initial values</span>
00564     Real fResult = fSignal;
00565     Real fWeight = 1.0;
00566 
00567     <span class="comment">// inner loop of spectral construction, where the fractal is built</span>
00568     <span class="keywordflow">for</span> ( i = 0; i &lt; fOctaves; i++ )
00569     {
00570         <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00571         fX *= fLacunarity;
00572         fY *= fLacunarity;
00573         fZ *= fLacunarity;
00574 
00575         <span class="comment">// weight successive contributions by previous signal, clamp [0.0,1.0]</span>
00576         fWeight = <a class="code" href="namespaceSpark.html#a42">Clamp</a>( fSignal * fThreshold, 0.0, 1.0 );
00577 
00578         <span class="comment">// get absolute value of signal (this creates the ridges)</span>
00579         fSignal = <a class="code" href="namespaceSpark.html#a40">Abs</a>( <a class="code" href="namespaceSpark.html#a74">GradientNoise</a>(fX, fY, fZ ));
00580 
00581         <span class="comment">// invert and translate (note that "offset" should be ~= 1.0)</span>
00582         fSignal = fOffset - fSignal;
00583 
00584         <span class="comment">// square the signal, to increase "sharpness" of ridges</span>
00585         fSignal *= fSignal;
00586 
00587         <span class="comment">// weight the contribution</span>
00588         fSignal *= fWeight;
00589 
00590         <span class="comment">// accumulate the result</span>
00591         fResult += (Real)(fSignal * afExponents[i]);
00592 
00593     }
00594     <span class="keywordflow">return</span> fResult;
00595 }
00596 <span class="comment">// ---------------------------------------------------------------------------</span>
00597 <span class="keyword">template</span>&lt; <span class="keyword">class</span> Real &gt;
<a name="l00598"></a><a class="code" href="namespaceSpark.html#a71">00598</a> Real <a class="code" href="namespaceSpark.html#a71">Spark::Quadric</a>(Real fA, Real fB, Real fC)
00599 {
00600     Real fT = 0.0;
00601     Real fDet = fB*fB - 4.0f*fA*fC;
00602     fA *= 2.0f;
00603     <span class="keywordflow">if</span> (fDet &gt; 0.0f)
00604     {
00605         fDet = <a class="code" href="namespaceSpark.html#a51">Sqrt</a>(fDet);
00606         fT = (fB - fDet)/fA;
00607         <span class="keywordflow">if</span> (fT &gt; 0.0f)
00608         {
00609             <span class="keywordflow">return</span> fT;
00610         }
00611         <span class="keywordflow">else</span>
00612         {
00613             fT = (fB + fDet)/fA;
00614             <span class="keywordflow">return</span> fT;
00615         }
00616     }
00617     <span class="keywordflow">else</span>
00618     {
00619        fT = -1.0;
00620     }
00621     <span class="keywordflow">return</span> fT;
00622 }
00623 <span class="comment">// ---------------------------------------------------------------------------</span>
00624 <span class="keyword">template</span>&lt; <span class="keyword">class</span> Real &gt;
<a name="l00625"></a><a class="code" href="namespaceSpark.html#a84">00625</a> Real <a class="code" href="namespaceSpark.html#a84">Spark::VoronoiNoise</a>(
00626     Real fX, Real fY, Real fZ,
00627     Real fJitter,
00628     Real&amp; rfOX, Real&amp; rfOY, Real&amp; rfOZ)
00629 {
00630     Real fCX = <a class="code" href="namespaceSpark.html#a44">Floor</a>(fX) + 0.5f;
00631     Real fCY = <a class="code" href="namespaceSpark.html#a44">Floor</a>(fY) + 0.5f;
00632     Real fCZ = <a class="code" href="namespaceSpark.html#a44">Floor</a>(fZ) + 0.5f;
00633 
00634     Real f1 = 1000;
00635     Real i, j, k;
00636     <span class="keywordflow">for</span> (i = -1;  i &lt;= 1;  i += 1)
00637     {
00638         <span class="keywordflow">for</span> (j = -1;  j &lt;= 1;  j += 1)
00639         {
00640             <span class="keywordflow">for</span> (k = -1;  k &lt;= 1;  k += 1)
00641             {
00642                 Real fTX = fCX + i;
00643                 Real fTY = fCY + j;
00644                 Real fTZ = fCZ + k;
00645 
00646                 Real fNoise = <a class="code" href="namespaceSpark.html#a73">CellNoise</a>(fTX, fTY, fTZ);
00647 
00648                 Real fPX = fTX + fJitter * fNoise - 0.5f;
00649                 Real fPY = fTY + fJitter * fNoise - 0.5f;
00650                 Real fPZ = fTZ + fJitter * fNoise - 0.5f;
00651 
00652                 Real fDX = fPX - fX;
00653                 Real fDY = fPY - fY;
00654                 Real fDZ = fPZ - fZ;
00655 
00656                 Real fDistSqr = fDX*fDX + fDY*fDY + fDZ*fDZ;
00657 
00658                 <span class="keywordflow">if</span>(fDistSqr &lt; f1)
00659                 {
00660                     f1 = fDistSqr;
00661                     rfOX = fPX;
00662                     rfOY = fPY;
00663                     rfOZ = fPZ;
00664                 }
00665             }
00666         }
00667     }
00668     <span class="keywordflow">return</span> <a class="code" href="namespaceSpark.html#a51">Sqrt</a>(f1);
00669 }
00670 <span class="comment">// ---------------------------------------------------------------------------</span>
</div></pre>		<div class="footer" width="100%">
		<hr>
			<a href="http://lyon-smith.org/">&copy; Derek Gerstmann - NCCA - Bournemouth University - 2004</a>
		</div>
		<br>
	</body>
</html>
