<html>
	<head>
		<title>SPARK: Stream Processing Abstraction and Rendering Toolkit</title>
		<link HREF="style.css" REL="stylesheet" TYPE="text/css">
	</head>
	<body>
		<div width="100%" height="40px" class="banner">
			Spark API Documentation
		</div>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>SpStreamBuffer.cpp</h1><a href="SpStreamBuffer_8cpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">// #############################################################################</span>
00002 <span class="comment">// # SpStreamBuffer.cpp : A multi-format OpenGL render-to-texture interface</span>
00003 <span class="comment">// #</span>
00004 <span class="comment">// # Created    : Aug 2004</span>
00005 <span class="comment">// # Copyright  : (see license below)</span>
00006 <span class="comment">// #</span>
00007 <span class="comment">// #############################################################################</span>
00008 
00009 <span class="comment">// =============================================================================</span>
00010 <span class="comment">//</span>
00011 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
00012 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
00013 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
00014 <span class="comment">//  (at your option) any later version.</span>
00015 <span class="comment">//</span>
00016 <span class="comment">// =============================================================================</span>
00017 
00018 <span class="comment">// =============================================================================</span>
00019 <span class="comment">//</span>
00020 <span class="comment">// Copyright (c) 2002-2004 Mark J. Harris</span>
00021 <span class="comment">//</span>
00022 <span class="comment">// This software is provided 'as-is', without any express or implied</span>
00023 <span class="comment">// warranty. In no event will the authors be held liable for any</span>
00024 <span class="comment">// damages arising from the use of this software.</span>
00025 <span class="comment">//</span>
00026 <span class="comment">// Permission is granted to anyone to use this software for any</span>
00027 <span class="comment">// purpose, including commercial applications, and to alter it and</span>
00028 <span class="comment">// redistribute it freely, subject to the following restrictions:</span>
00029 <span class="comment">//</span>
00030 <span class="comment">// 1. The origin of this software must not be misrepresented; you</span>
00031 <span class="comment">//    must not claim that you wrote the original software. If you use</span>
00032 <span class="comment">//    this software in a product, an acknowledgment in the product</span>
00033 <span class="comment">//    documentation would be appreciated but is not required.</span>
00034 <span class="comment">//</span>
00035 <span class="comment">// 2. Altered source versions must be plainly marked as such, and</span>
00036 <span class="comment">//    must not be misrepresented as being the original software.</span>
00037 <span class="comment">//</span>
00038 <span class="comment">// 3. This notice may not be removed or altered from any source</span>
00039 <span class="comment">//    distribution.</span>
00040 <span class="comment">//</span>
00041 <span class="comment">// =============================================================================</span>
00042 <span class="comment">// Credits:</span>
00043 <span class="comment">//</span>
00044 <span class="comment">// Original SpStreamBuffer code: Mark J. Harris</span>
00045 <span class="comment">// Original Render-to-depth-texture support: Thorsten Scheuermann</span>
00046 <span class="comment">// Additional Refactoring: Derek Gerstmann</span>
00047 <span class="comment">// OSX Support: Derek Gerstmann</span>
00048 <span class="comment">// Linux Copy-to-texture: Eric Werness</span>
00049 <span class="comment">// Various Bug Fixes: Daniel (Redge) Sperl</span>
00050 <span class="comment">//                    Bill Baxter</span>
00051 <span class="comment">//</span>
00052 <span class="comment">// =============================================================================</span>
00053 
00054 <span class="preprocessor">#pragma warning(disable:4786)</span>
00055 <span class="preprocessor"></span>
00056 <span class="preprocessor">#include "<a class="code" href="SpStreamBuffer_8h.html">SpStreamBuffer.h</a>"</span>
00057 
00058 <span class="comment">//#include &lt;GL/glut.h&gt;</span>
00059 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00060 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00061 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00062 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00063 
00064 <span class="preprocessor">#ifdef _WIN32</span>
00065 <span class="preprocessor"></span><span class="preprocessor">#pragma comment(lib, "gdi32.lib") // required for GetPixelFormat()</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00067 <span class="preprocessor"></span>
00068 <span class="comment">// ---------------------------------------------------------------------------</span>
00069 
00070 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00071 <span class="keyword">using</span> <span class="keyword">namespace </span>Spark;
00072 
00073 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00074"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#a0">00074</a> <a class="code" href="classSpark_1_1SpStreamBuffer.html#a0">SpStreamBuffer::SpStreamBuffer</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *acModeString)
00075 :   m_iWidth(0),
00076     m_iHeight(0),
00077     m_bIsTexture(false),
00078     m_bIsDepthTexture(false),
00079     m_bHasARBDepthTexture(true),            <span class="comment">// [Redge]</span>
00080     m_eUpdateMode(RT_RENDER_TO_TEXTURE),
00081     m_bInitialized(false),
00082     m_iNumAuxBuffers(0),
00083     m_bIsBufferBound(false),
00084     m_iCurrentBoundBuffer(0),
00085     m_uiDepthBits(0),
00086     m_uiStencilBits(0),
00087     m_bIsFloat(false),
00088     m_bIsDoubleBuffered(false),
00089     m_bIsPowerOf2(true),
00090     m_bIsRectangle(false),
00091     m_bIsMipMapped(false),
00092     m_bShareObjects(false),
00093     m_bCopyContext(false),
00094 #ifdef _WIN32
00095     m_hDC(NULL),
00096     m_hGLContext(NULL),
00097     m_hPixelBuffer(NULL),
00098     m_hPreviousDC(0),
00099     m_hPreviousContext(0),
00100 #else
00101     m_pkDisplay(NULL),
00102     m_hGLContext(NULL),
00103     m_hPixelBuffer(0),
00104     m_hPreviousContext(0),
00105     m_hPreviousDrawable(0),
00106 #endif
00107     m_eTextureTarget(GL_NONE),
00108     m_uiTextureId(0),
00109     m_uiDepthTextureId(0),
00110     m_ausPoorDepthTexture(0) <span class="comment">// [Redge]</span>
00111 {
00112     <span class="keywordflow">if</span>(acModeString)
00113         <a class="code" href="classSpark_1_1SpStreamBuffer.html#p32">m_kModeString</a> = <a class="code" href="classSpark_1_1SpString.html">SpString</a>(acModeString); <span class="comment">// [DG]</span>
00114 
00115     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[0] = <a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[1] =
00116         m_uiColorBits[2] = m_uiColorBits[3] = 0;
00117 
00118 <span class="preprocessor">#ifdef _WIN32</span>
00119 <span class="preprocessor"></span>    <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>.push_back(WGL_DRAW_TO_PBUFFER_ARB);
00120     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>.push_back(<span class="keyword">true</span>);
00121     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>.push_back(WGL_SUPPORT_OPENGL_ARB);
00122     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>.push_back(<span class="keyword">true</span>);
00123 
00124     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.push_back(WGL_PBUFFER_LARGEST_ARB);
00125     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.push_back(<span class="keyword">true</span>);
00126 <span class="preprocessor">#else</span>
00127 <span class="preprocessor"></span>    <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.push_back(GLX_RENDER_TYPE_SGIX);
00128     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.push_back(GLX_RGBA_BIT_SGIX);
00129     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.push_back(GLX_DRAWABLE_TYPE_SGIX);
00130     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.push_back(GLX_PBUFFER_BIT_SGIX);
00131 <span class="preprocessor">#endif</span>
00132 <span class="preprocessor"></span>
00133     <a class="code" href="classSpark_1_1SpStreamBuffer.html#b1">parseModeString</a>(acModeString, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>);
00134 
00135 <span class="preprocessor">#ifdef _WIN32</span>
00136 <span class="preprocessor"></span>    <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>.push_back(0);
00137     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.push_back(0);
00138 <span class="preprocessor">#else</span>
00139 <span class="preprocessor"></span>    <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>.push_back(None);
00140 <span class="preprocessor">#endif</span>
00141 <span class="preprocessor"></span>}
00142 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00143"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#a1">00143</a> <a class="code" href="classSpark_1_1SpStreamBuffer.html#a1">SpStreamBuffer::~SpStreamBuffer</a>()
00144 {
00145     <a class="code" href="classSpark_1_1SpStreamBuffer.html#b0">invalidate</a>();
00146 }
00147 <span class="comment">// ---------------------------------------------------------------------------</span>
00148 <span class="preprocessor">#ifdef _WIN32</span>
00149 <span class="preprocessor"></span><span class="comment">// ---------------------------------------------------------------------------</span>
00150 <span class="keywordtype">void</span> wglGetLastError()
00151 {
00152     <span class="comment">//</span>
00153     <span class="comment">// Returns the last windows error generated.</span>
00154     <span class="comment">//</span>
00155 
00156 <span class="preprocessor">#ifdef _DEBUG</span>
00157 <span class="preprocessor"></span>
00158     DWORD iError = GetLastError();
00159     <span class="keywordflow">switch</span>(iError)
00160     {
00161     <span class="keywordflow">case</span> ERROR_INVALID_PIXEL_FORMAT:
00162         fprintf(stderr,
00163                 <span class="stringliteral">"SpStreamBuffer Win32 Error:  ERROR_INVALID_PIXEL_FORMAT\n"</span>);
00164         <span class="keywordflow">break</span>;
00165     <span class="keywordflow">case</span> ERROR_NO_SYSTEM_RESOURCES:
00166         fprintf(stderr,
00167                 <span class="stringliteral">"SpStreamBuffer Win32 Error:  ERROR_NO_SYSTEM_RESOURCES\n"</span>);
00168         <span class="keywordflow">break</span>;
00169     <span class="keywordflow">case</span> ERROR_INVALID_DATA:
00170         fprintf(stderr,
00171                 <span class="stringliteral">"SpStreamBuffer Win32 Error:  ERROR_INVALID_DATA\n"</span>);
00172         <span class="keywordflow">break</span>;
00173     <span class="keywordflow">case</span> ERROR_INVALID_WINDOW_HANDLE:
00174         fprintf(stderr,
00175                 <span class="stringliteral">"SpStreamBuffer Win32 Error:  ERROR_INVALID_WINDOW_HANDLE\n"</span>);
00176         <span class="keywordflow">break</span>;
00177     <span class="keywordflow">case</span> ERROR_RESOURCE_TYPE_NOT_FOUND:
00178         fprintf(stderr,
00179                 <span class="stringliteral">"SpStreamBuffer Win32 Error:  ERROR_RESOURCE_TYPE_NOT_FOUND\n"</span>);
00180         <span class="keywordflow">break</span>;
00181     <span class="keywordflow">case</span> ERROR_SUCCESS:
00182         <span class="comment">// no error</span>
00183         <span class="keywordflow">break</span>;
00184     <span class="keywordflow">default</span>:
00185         LPVOID lpMsgBuf;
00186         FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
00187             FORMAT_MESSAGE_FROM_SYSTEM |
00188             FORMAT_MESSAGE_IGNORE_INSERTS,
00189             NULL,
00190             iError,
00191             MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), <span class="comment">// Default language</span>
00192             (LPTSTR) &amp;lpMsgBuf,
00193             0,
00194             NULL);
00195 
00196         fprintf(stderr, <span class="stringliteral">"SpStreamBuffer Win32 Error %d: %s\n"</span>, iError, lpMsgBuf);
00197         LocalFree( lpMsgBuf );
00198         <span class="keywordflow">break</span>;
00199     }
00200     SetLastError(0);
00201 
00202 <span class="preprocessor">#endif // _DEBUG</span>
00203 <span class="preprocessor"></span>}
00204 <span class="preprocessor">#endif</span>
00205 <span class="preprocessor"></span><span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00206"></a><a class="code" href="SpStreamBuffer_8cpp.html#a0">00206</a> <span class="keywordtype">void</span> <a class="code" href="SpStreamBuffer_8cpp.html#a0">PrintExtensionError</a>( <span class="keywordtype">char</span>* acMessage, ... )
00207 {
00208     <span class="comment">//</span>
00209     <span class="comment">// Prints an error about missing OpenGL extensions.</span>
00210     <span class="comment">//</span>
00211 
00212     fprintf(stderr,
00213             <span class="stringliteral">"Error: SpStreamBuffer requires the following unsupported "</span>
00214             <span class="stringliteral">"OpenGL extensions: \n"</span>);
00215     <span class="keywordtype">char</span> acBuffer[512];
00216     va_list kArgs;
00217     va_start(kArgs, acMessage);
00218 <span class="preprocessor">#ifdef _WIN32</span>
00219 <span class="preprocessor"></span>    _vsnprintf( acBuffer, 512, acMessage, kArgs );
00220 <span class="preprocessor">#else</span>
00221 <span class="preprocessor"></span>    vsnprintf( acBuffer, 512, acMessage, kArgs );
00222 <span class="preprocessor">#endif</span>
00223 <span class="preprocessor"></span>    va_end(kArgs);
00224 
00225     fprintf(stderr, acMessage);
00226 }
00227 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00228"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#a2">00228</a> <span class="keywordtype">bool</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#a2">SpStreamBuffer::initialize</a>(<span class="keywordtype">int</span> iWidth, <span class="keywordtype">int</span> iHeight,
00229                                 <span class="keywordtype">bool</span> bShareObjects       <span class="comment">/* = true */</span>,
00230                                 <span class="keywordtype">bool</span> bCopyContext        <span class="comment">/* = false */</span>)
00231 {
00232     <span class="comment">//</span>
00233     <span class="comment">// This function creates the actual buffer.  It can only be called once a GL</span>
00234     <span class="comment">// context has already been created.</span>
00235     <span class="comment">//</span>
00236 
00237     assert(iWidth &gt; 0 &amp;&amp; iHeight &gt; 0);
00238 
00239     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a> = iWidth; <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a> = iHeight;
00240     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p16">m_bIsPowerOf2</a> = <a class="code" href="classSpark_1_1SpStreamBuffer.html#e0">isPowerOfTwo</a>(iWidth) &amp;&amp; <a class="code" href="classSpark_1_1SpStreamBuffer.html#e0">isPowerOfTwo</a>(iHeight);
00241 
00242     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p19">m_bShareObjects</a> = bShareObjects;
00243     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p20">m_bCopyContext</a>  = bCopyContext;
00244 
00245     <span class="comment">// Check if this is an NVXX GPU and verify necessary extensions.</span>
00246     <span class="keywordflow">if</span> (!<a class="code" href="classSpark_1_1SpStreamBuffer.html#b4">verifyExtensions</a>())
00247         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00248 
00249     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p6">m_bInitialized</a>)
00250         <a class="code" href="classSpark_1_1SpStreamBuffer.html#b0">invalidate</a>();
00251 
00252 <span class="preprocessor">#if _WIN32</span>
00253 <span class="preprocessor"></span>    <span class="comment">// Get the current kContext.</span>
00254     HDC hDC = wglGetCurrentDC();
00255     <span class="keywordflow">if</span> (NULL == hDC)
00256         wglGetLastError();
00257     HGLRC hGLRC = wglGetCurrentContext();
00258     <span class="keywordflow">if</span> (NULL == hGLRC)
00259         wglGetLastError();
00260 
00261     <span class="keywordtype">int</span> iFormat = 0;
00262     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iNumFormats;
00263 
00264     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p20">m_bCopyContext</a>)
00265     {
00266         <span class="comment">// Get the pixel format for the on-iScreen window.</span>
00267         iFormat = GetPixelFormat(hDC);
00268         <span class="keywordflow">if</span> (iFormat == 0)
00269         {
00270             fprintf(stderr,
00271                     <span class="stringliteral">"SpStreamBuffer Error: GetPixelFormat() failed.\n"</span>);
00272             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00273         }
00274     }
00275     <span class="keywordflow">else</span>
00276     {
00277         <span class="keywordflow">if</span> (!wglChoosePixelFormatARB(hDC, &amp;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>[0], NULL,
00278                                      1, &amp;iFormat, &amp;iNumFormats))
00279         {
00280             fprintf(stderr,
00281                 <span class="stringliteral">"SpStreamBuffer Error: wglChoosePixelFormatARB() failed.\n"</span>);
00282             wglGetLastError();
00283             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00284         }
00285         <span class="keywordflow">if</span> ( iNumFormats &lt;= 0 )
00286         {
00287             fprintf(stderr,
00288                     <span class="stringliteral">"SpStreamBuffer Error: Couldn't find a suitable "</span>
00289                     <span class="stringliteral">"pixel format.\n"</span>);
00290             wglGetLastError();
00291             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00292         }
00293     }
00294 
00295     <span class="comment">// Create the p-buffer.</span>
00296     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a> = wglCreatePbufferARB(hDC, iFormat, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a>,
00297                                          &amp;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>[0]);
00298     <span class="keywordflow">if</span> (!<a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>)
00299     {
00300         fprintf(stderr,
00301                 <span class="stringliteral">"SpStreamBuffer Error: wglCreatePbufferARB() failed.\n"</span>);
00302         wglGetLastError();
00303         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00304     }
00305 
00306     <span class="comment">// Get the device kContext.</span>
00307     m_hDC = wglGetPbufferDCARB( <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>);
00308     <span class="keywordflow">if</span> ( !m_hDC )
00309     {
00310         fprintf(stderr,
00311                 <span class="stringliteral">"SpStreamBuffer Error: wglGetGetPbufferDCARB() failed.\n"</span>);
00312         wglGetLastError();
00313         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00314     }
00315 
00316     <span class="comment">// Create a gl kContext for the p-buffer.</span>
00317     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p20">m_bCopyContext</a>)
00318     {
00319         <span class="comment">// Let's use the same gl kContext..</span>
00320         <span class="comment">// Since the device kContexts are compatible (i.e. same pixelformat),</span>
00321         <span class="comment">// we should be able to use the same gl rendering kContext.</span>
00322         <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a> = hGLRC;
00323     }
00324     <span class="keywordflow">else</span>
00325     {
00326         <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a> = wglCreateContext( m_hDC );
00327         <span class="keywordflow">if</span> ( !<a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a> )
00328         {
00329             fprintf(stderr,
00330                     <span class="stringliteral">"SpStreamBuffer Error: wglCreateContext() failed.\n"</span>);
00331             wglGetLastError();
00332             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00333         }
00334     }
00335 
00336     <span class="comment">// Share lists, texture objects, and program objects.</span>
00337     <span class="keywordflow">if</span>( <a class="code" href="classSpark_1_1SpStreamBuffer.html#p19">m_bShareObjects</a> )
00338     {
00339         <span class="keywordflow">if</span>( !wglShareLists(hGLRC, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a>) )
00340         {
00341             fprintf(stderr,
00342                     <span class="stringliteral">"SpStreamBuffer Error: wglShareLists() failed.\n"</span>);
00343             wglGetLastError();
00344             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00345         }
00346     }
00347 
00348     <span class="comment">// Determine the actual iWidth and iHeight we were able to create.</span>
00349     wglQueryPbufferARB( <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>, WGL_PBUFFER_WIDTH_ARB, &amp;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a> );
00350     wglQueryPbufferARB( <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>, WGL_PBUFFER_HEIGHT_ARB, &amp;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a> );
00351 
00352     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p6">m_bInitialized</a> = <span class="keyword">true</span>;
00353 
00354     <span class="comment">// get the actual number of bits allocated:</span>
00355     <span class="keywordtype">int</span> iAttribute = WGL_RED_BITS_ARB;
00356     <span class="comment">//int bits[6];</span>
00357     <span class="keywordtype">int</span> iValue;
00358     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[0] =
00359         (wglGetPixelFormatAttribivARB(m_hDC, iFormat, 0, 1, &amp;iAttribute, &amp;iValue))
00360         ? iValue : 0;
00361     iAttribute = WGL_GREEN_BITS_ARB;
00362     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[1] =
00363         (wglGetPixelFormatAttribivARB(m_hDC, iFormat, 0, 1, &amp;iAttribute, &amp;iValue))
00364         ? iValue : 0;
00365     iAttribute = WGL_BLUE_BITS_ARB;
00366     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[2] =
00367         (wglGetPixelFormatAttribivARB(m_hDC, iFormat, 0, 1, &amp;iAttribute, &amp;iValue))
00368         ? iValue : 0;
00369     iAttribute = WGL_ALPHA_BITS_ARB;
00370     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[3] =
00371         (wglGetPixelFormatAttribivARB(m_hDC, iFormat, 0, 1, &amp;iAttribute, &amp;iValue))
00372         ? iValue : 0;
00373     iAttribute = WGL_DEPTH_BITS_ARB;
00374     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p12">m_uiDepthBits</a> =
00375         (wglGetPixelFormatAttribivARB(m_hDC, iFormat, 0, 1, &amp;iAttribute, &amp;iValue))
00376         ? iValue : 0;
00377     iAttribute = WGL_STENCIL_BITS_ARB;
00378     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p13">m_uiStencilBits</a> =
00379         (wglGetPixelFormatAttribivARB(m_hDC, iFormat, 0, 1, &amp;iAttribute, &amp;iValue))
00380         ? iValue : 0;
00381     iAttribute = WGL_DOUBLE_BUFFER_ARB;
00382     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p15">m_bIsDoubleBuffered</a> =
00383         (wglGetPixelFormatAttribivARB(m_hDC, iFormat, 0, 1, &amp;iAttribute, &amp;iValue))
00384         ? (iValue?<span class="keyword">true</span>:<span class="keyword">false</span>) : <span class="keyword">false</span>;
00385 
00386 <span class="preprocessor">#if defined(_DEBUG) | defined(DEBUG)</span>
00387 <span class="preprocessor"></span>    fprintf(stderr, <span class="stringliteral">"Created a %dx%d SpStreamBuffer with BPP(%d, %d, %d, %d)"</span>,
00388         <a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a>,
00389         <a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[0], <a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[1],
00390         <a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[2], <a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[3]);
00391     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p12">m_uiDepthBits</a>) fprintf(stderr, <span class="stringliteral">" depth=%d"</span>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p12">m_uiDepthBits</a>);
00392     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p13">m_uiStencilBits</a>) fprintf(stderr, <span class="stringliteral">" stencil=%d"</span>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p13">m_uiStencilBits</a>);
00393     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p15">m_bIsDoubleBuffered</a>) fprintf(stderr, <span class="stringliteral">" double buffered"</span>);
00394     fprintf(stderr, <span class="stringliteral">"\n"</span>);
00395 <span class="preprocessor">#endif</span>
00396 <span class="preprocessor"></span>
00397 <span class="preprocessor">#else // !_WIN32</span>
00398 <span class="preprocessor"></span>    <a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a> = glXGetCurrentDisplay();
00399     GLXContext kContext = glXGetCurrentContext();
00400     <span class="keywordtype">int</span> iScreen = DefaultScreen(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>);
00401     XVisualInfo *pkVisualInfo;
00402 
00403     <span class="keywordtype">int</span> iFormat = 0;
00404     <span class="keywordtype">int</span> iNumFormats;
00405     <span class="keywordtype">int</span> iAttribute = 0;
00406 
00407     GLXFBConfigSGIX *pkFBConfigs;
00408     <span class="keywordtype">int</span> iConfigs;
00409 
00410     pkFBConfigs = glXChooseFBConfigSGIX(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>, iScreen,
00411                                       &amp;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>[0], &amp;iConfigs);
00412 
00413     <span class="keywordflow">if</span> (iConfigs == 0 || !pkFBConfigs)
00414     {
00415         fprintf(stderr,
00416             <span class="stringliteral">"SpStreamBuffer Error: Couldn't find a suitable pixel format.\n"</span>);
00417         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00418     }
00419 
00420     <span class="comment">// Pick the first returned format that will return a pbuffer</span>
00421     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;iConfigs;i++)
00422     {
00423         <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a> = glXCreateGLXPbufferSGIX(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>, pkFBConfigs[i],
00424                                             <a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a>, NULL);
00425         <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>)
00426         {
00427             <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a> = glXCreateContextWithConfigSGIX(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>,
00428                                                          pkFBConfigs[i],
00429                                                          GLX_RGBA_TYPE,
00430                                                          <a class="code" href="classSpark_1_1SpStreamBuffer.html#p19">m_bShareObjects</a> ? kContext : NULL,
00431                                                          True);
00432             <span class="keywordflow">break</span>;
00433         }
00434     }
00435 
00436     <span class="keywordflow">if</span> (!<a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>)
00437     {
00438         fprintf(stderr,
00439                 <span class="stringliteral">"SpStreamBuffer Error: glXCreateGLXPbufferSGIX() failed.\n"</span>);
00440         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00441     }
00442 
00443     <span class="keywordflow">if</span>(!<a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a>)
00444     {
00445         <span class="comment">// Try indirect</span>
00446         <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a> = glXCreateContext(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>, pkVisualInfo,
00447                                        <a class="code" href="classSpark_1_1SpStreamBuffer.html#p19">m_bShareObjects</a> ? kContext : NULL, False);
00448         <span class="keywordflow">if</span> ( !<a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a> )
00449         {
00450             fprintf(stderr,
00451                     <span class="stringliteral">"SpStreamBuffer Error: glXCreateContext() failed.\n"</span>);
00452             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00453         }
00454     }
00455 
00456     glXQueryGLXPbufferSGIX(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>, GLX_WIDTH_SGIX,
00457                            (GLuint*)&amp;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a>);
00458     glXQueryGLXPbufferSGIX(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>, GLX_HEIGHT_SGIX,
00459                            (GLuint*)&amp;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a>);
00460 
00461     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p6">m_bInitialized</a> = <span class="keyword">true</span>;
00462 
00463     <span class="comment">// XXX Query the color format</span>
00464 
00465 <span class="preprocessor">#endif</span>
00466 <span class="preprocessor"></span>
00467 
00468     <span class="comment">// Now that the pbuffer is created, allocate any texture objects needed,</span>
00469     <span class="comment">// and initialize them (for CTT updates only).  These must be allocated</span>
00470     <span class="comment">// in the kContext of the pbuffer, though, or the RT won't work without</span>
00471     <span class="comment">// wglShareLists.</span>
00472 <span class="preprocessor">#ifdef _WIN32</span>
00473 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<span class="keyword">false</span> == wglMakeCurrent( m_hDC, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a>))
00474     {
00475         wglGetLastError();
00476         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00477     }
00478 <span class="preprocessor">#else</span>
00479 <span class="preprocessor"></span>    <a class="code" href="classSpark_1_1SpStreamBuffer.html#p25">m_hPreviousContext</a> = glXGetCurrentContext();
00480     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p24">m_hPreviousDrawable</a> = glXGetCurrentDrawable();
00481 
00482     <span class="keywordflow">if</span> (False == glXMakeCurrent(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a>))
00483     {
00484         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00485     }
00486 <span class="preprocessor">#endif</span>
00487 <span class="preprocessor"></span>
00488     <span class="keywordtype">bool</span> result = <a class="code" href="classSpark_1_1SpStreamBuffer.html#b5">initializeTextures</a>();
00489 <span class="preprocessor">#ifdef _WIN32</span>
00490 <span class="preprocessor"></span>    <a class="code" href="classSpark_1_1SpStreamBuffer.html#a11">bindBuffer</a>(WGL_FRONT_LEFT_ARB);
00491     <a class="code" href="classSpark_1_1SpStreamBuffer.html#b9">bindDepthBuffer</a>();
00492 <span class="preprocessor">#endif</span>
00493 <span class="preprocessor"></span>
00494 
00495 <span class="preprocessor">#ifdef _WIN32</span>
00496 <span class="preprocessor"></span>    <span class="comment">// make the previous rendering context current</span>
00497     <span class="keywordflow">if</span> (<span class="keyword">false</span> == wglMakeCurrent( hDC, hGLRC))
00498     {
00499         wglGetLastError();
00500         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00501     }
00502 <span class="preprocessor">#else</span>
00503 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (False == glXMakeCurrent(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>,
00504                                 <a class="code" href="classSpark_1_1SpStreamBuffer.html#p24">m_hPreviousDrawable</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p25">m_hPreviousContext</a>))
00505     {
00506         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00507     }
00508 <span class="preprocessor">#endif</span>
00509 <span class="preprocessor"></span>
00510     <span class="keywordflow">return</span> result;
00511 }
00512 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00513"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#b0">00513</a> <span class="keywordtype">bool</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#b0">SpStreamBuffer::invalidate</a>()
00514 {
00515     <span class="comment">// Returns the buffer memory to the graphics device.</span>
00516 
00517     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[0] = <a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[1] =
00518         m_uiColorBits[2] = m_uiColorBits[3] = 0;
00519     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p12">m_uiDepthBits</a> = 0;
00520     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p13">m_uiStencilBits</a> = 0;
00521 
00522     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a>)
00523         glDeleteTextures(1, &amp;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p27">m_uiTextureId</a>);
00524     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a>)
00525     {
00526         <span class="comment">// [Redge]</span>
00527         <span class="keywordflow">if</span> (!<a class="code" href="classSpark_1_1SpStreamBuffer.html#p4">m_bHasARBDepthTexture</a>)
00528             <span class="keyword">delete</span>[] <a class="code" href="classSpark_1_1SpStreamBuffer.html#p29">m_ausPoorDepthTexture</a>;
00529 
00530         <span class="comment">// [/Redge]</span>
00531         glDeleteTextures(1, &amp;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p28">m_uiDepthTextureId</a>);
00532     }
00533 
00534 <span class="preprocessor">#if _WIN32</span>
00535 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ( <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a> )
00536     {
00537         <span class="comment">// Check if we are currently rendering in the pbuffer</span>
00538         <span class="keywordflow">if</span> (wglGetCurrentContext() == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a>)
00539             wglMakeCurrent(0,0);
00540 
00541         <span class="keywordflow">if</span> (!<a class="code" href="classSpark_1_1SpStreamBuffer.html#p20">m_bCopyContext</a>)
00542             wglDeleteContext( <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a>);
00543 
00544         wglReleasePbufferDCARB( <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>, m_hDC);
00545         wglDestroyPbufferARB( <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a> );
00546         <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a> = 0;
00547         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00548     }
00549 <span class="preprocessor">#else</span>
00550 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ( <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a> )
00551     {
00552         <span class="keywordflow">if</span>(glXGetCurrentContext() == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a>)
00553             <span class="comment">// XXX I don't know if this is right at all</span>
00554             glXMakeCurrent(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>, 0);
00555 
00556         glXDestroyGLXPbufferSGIX(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>);
00557         <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a> = 0;
00558         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00559     }
00560 <span class="preprocessor">#endif</span>
00561 <span class="preprocessor"></span>
00562     <span class="comment">// [WVB] do we need to call releaseBoundBuffers() too?</span>
00563     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00564 }
00565 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00566"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#a3">00566</a> <span class="keywordtype">bool</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#a3">SpStreamBuffer::reset</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *acModeString, ...)
00567 {
00568     <span class="comment">//</span>
00569     <span class="comment">// Causes the buffer to delete itself.  User must call initialize() again</span>
00570     <span class="comment">// before use.</span>
00571     <span class="comment">//</span>
00572 
00573     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a> = 0; <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a> = 0;
00574     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a> = <span class="keyword">false</span>;
00575     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a> = <span class="keyword">false</span>,
00576     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p4">m_bHasARBDepthTexture</a> = <span class="keyword">true</span>;
00577     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a> = <a class="code" href="classSpark_1_1SpStreamBuffer.html#w2w0">RT_RENDER_TO_TEXTURE</a>;
00578     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p6">m_bInitialized</a> = <span class="keyword">false</span>;
00579     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p7">m_iNumAuxBuffers</a> = 0;
00580     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p8">m_bIsBufferBound</a> = <span class="keyword">false</span>;
00581     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p9">m_iCurrentBoundBuffer</a> = 0;
00582     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p12">m_uiDepthBits</a> = 0;
00583     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p13">m_uiStencilBits</a> = 0;
00584     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p15">m_bIsDoubleBuffered</a> = <span class="keyword">false</span>;
00585     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p14">m_bIsFloat</a> = <span class="keyword">false</span>;
00586     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p16">m_bIsPowerOf2</a> = <span class="keyword">true</span>;
00587     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p17">m_bIsRectangle</a> = <span class="keyword">false</span>;
00588     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p18">m_bIsMipMapped</a> = <span class="keyword">false</span>;
00589     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p19">m_bShareObjects</a> = <span class="keyword">false</span>;
00590     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p20">m_bCopyContext</a> = <span class="keyword">false</span>;
00591     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a> = GL_NONE;
00592     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p27">m_uiTextureId</a> = 0;
00593     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p28">m_uiDepthTextureId</a> = 0;
00594     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p29">m_ausPoorDepthTexture</a> = 0;
00595     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>.clear();
00596     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.clear();
00597 
00598     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#a30">isInitialized</a>() &amp;&amp; !<a class="code" href="classSpark_1_1SpStreamBuffer.html#b0">invalidate</a>())
00599     {
00600         fprintf(stderr, <span class="stringliteral">"SpStreamBuffer::reset(): failed to invalidate.\n"</span>);
00601         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00602     }
00603 
00604     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[0] = <a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[1] =
00605         m_uiColorBits[2] = m_uiColorBits[3] = 0;
00606 
00607 <span class="preprocessor">#ifdef _WIN32</span>
00608 <span class="preprocessor"></span>    <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>.push_back(WGL_DRAW_TO_PBUFFER_ARB);
00609     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>.push_back(<span class="keyword">true</span>);
00610     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>.push_back(WGL_SUPPORT_OPENGL_ARB);
00611     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>.push_back(<span class="keyword">true</span>);
00612 
00613     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.push_back(WGL_PBUFFER_LARGEST_ARB);
00614     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.push_back(<span class="keyword">true</span>);
00615 <span class="preprocessor">#else</span>
00616 <span class="preprocessor"></span>    <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.push_back(GLX_RENDER_TYPE_SGIX);
00617     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.push_back(GLX_RGBA_BIT_SGIX);
00618     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.push_back(GLX_DRAWABLE_TYPE_SGIX);
00619     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.push_back(GLX_PBUFFER_BIT_SGIX);
00620 <span class="preprocessor">#endif</span>
00621 <span class="preprocessor"></span>
00622     va_list kArgs;
00623     <span class="keywordtype">char</span> acStringBuffer[256];
00624     va_start(kArgs,acModeString);
00625 <span class="preprocessor">#ifdef _WIN32</span>
00626 <span class="preprocessor"></span>    _vsnprintf( acStringBuffer, 256, acModeString, kArgs );
00627 <span class="preprocessor">#else</span>
00628 <span class="preprocessor"></span>    vsnprintf( acStringBuffer, 256, acModeString, kArgs );
00629 <span class="preprocessor">#endif</span>
00630 <span class="preprocessor"></span>    va_end(kArgs);
00631 
00632     <a class="code" href="classSpark_1_1SpStreamBuffer.html#b1">parseModeString</a>(acStringBuffer, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>);
00633 
00634 <span class="preprocessor">#ifdef _WIN32</span>
00635 <span class="preprocessor"></span>    <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>.push_back(0);
00636     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p31">m_kPixelBufferAttribs</a>.push_back(0);
00637 <span class="preprocessor">#else</span>
00638 <span class="preprocessor"></span>    <a class="code" href="classSpark_1_1SpStreamBuffer.html#p30">m_kPixelFormatAttribs</a>.push_back(None);
00639 <span class="preprocessor">#endif</span>
00640 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;
00641 }
00642 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00643"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#a4">00643</a> <span class="keywordtype">bool</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#a4">SpStreamBuffer::resize</a>(<span class="keywordtype">int</span> iWidth, <span class="keywordtype">int</span> iHeight)
00644 {
00645     <span class="comment">//</span>
00646     <span class="comment">// Like reset() this causes the buffer to delete itself.</span>
00647     <span class="comment">// But unlike reset(), this call re-initializes the SpStreamBuffer.</span>
00648     <span class="comment">// Note that resize() will not work after calling reset(), or before</span>
00649     <span class="comment">// calling initialize() the first time.</span>
00650     <span class="comment">//</span>
00651 
00652     <span class="keywordflow">if</span> (!<a class="code" href="classSpark_1_1SpStreamBuffer.html#p6">m_bInitialized</a>)
00653     {
00654         fprintf(stderr, <span class="stringliteral">"SpStreamBuffer::resize(): must initialize() first.\n"</span>);
00655         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00656     }
00657     <span class="keywordflow">if</span> (iWidth == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a> &amp;&amp; iHeight == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a>) {
00658         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00659     }
00660 
00661     <span class="comment">// Do same basic work as _Invalidate, but don't reset all our flags</span>
00662     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a>)
00663         glDeleteTextures(1, &amp;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p27">m_uiTextureId</a>);
00664     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a>)
00665         glDeleteTextures(1, &amp;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p28">m_uiDepthTextureId</a>);
00666 <span class="preprocessor">#ifdef _WIN32</span>
00667 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ( <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a> )
00668     {
00669         <span class="comment">// Check if we are currently rendering in the pbuffer</span>
00670         <span class="keywordflow">if</span> (wglGetCurrentContext() == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a>)
00671             wglMakeCurrent(0,0);
00672         <span class="keywordflow">if</span> (!<a class="code" href="classSpark_1_1SpStreamBuffer.html#p20">m_bCopyContext</a>)
00673             wglDeleteContext( <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a>);
00674         wglReleasePbufferDCARB( <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>, m_hDC);
00675         wglDestroyPbufferARB( <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a> );
00676         <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a> = 0;
00677         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00678     }
00679 <span class="preprocessor">#else</span>
00680 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ( <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a> )
00681     {
00682         <span class="keywordflow">if</span>(glXGetCurrentContext() == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a>)
00683             <span class="comment">// XXX I don't know if this is right at all</span>
00684             glXMakeCurrent(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>, 0);
00685         glXDestroyGLXPbufferSGIX(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>);
00686         <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a> = 0;
00687     }
00688 <span class="preprocessor">#endif</span>
00689 <span class="preprocessor"></span>    <span class="keywordflow">else</span> {
00690         fprintf(stderr, <span class="stringliteral">"SpStreamBuffer::resize(): failed to resize.\n"</span>);
00691         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00692     }
00693     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p6">m_bInitialized</a> = <span class="keyword">false</span>;
00694     <span class="keywordflow">return</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#a2">initialize</a>(iWidth, iHeight, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p19">m_bShareObjects</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p20">m_bCopyContext</a>);
00695 }
00696 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00697"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#a6">00697</a> <span class="keywordtype">bool</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#a6">SpStreamBuffer::enable</a>()
00698 {
00699     <span class="comment">// Activates rendering to the SpStreamBuffer.</span>
00700 
00701     <span class="keywordflow">if</span> (!<a class="code" href="classSpark_1_1SpStreamBuffer.html#p6">m_bInitialized</a>)
00702     {
00703         fprintf(stderr,
00704                 <span class="stringliteral">"SpStreamBuffer::enable(): Texture is not initialized!\n"</span>);
00705         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00706     }
00707 <span class="preprocessor">#ifdef _WIN32</span>
00708 <span class="preprocessor"></span>    <span class="comment">// cache the current context so we can reset it when disable() is called.</span>
00709     m_hPreviousDC      = wglGetCurrentDC();
00710     <span class="keywordflow">if</span> (NULL == m_hPreviousDC)
00711         wglGetLastError();
00712     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p25">m_hPreviousContext</a> = wglGetCurrentContext();
00713     <span class="keywordflow">if</span> (NULL == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p25">m_hPreviousContext</a>)
00714         wglGetLastError();
00715 <span class="preprocessor">#else</span>
00716 <span class="preprocessor"></span>    <a class="code" href="classSpark_1_1SpStreamBuffer.html#p25">m_hPreviousContext</a> = glXGetCurrentContext();
00717     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p24">m_hPreviousDrawable</a> = glXGetCurrentDrawable();
00718 <span class="preprocessor">#endif</span>
00719 <span class="preprocessor"></span>
00720     <a class="code" href="classSpark_1_1SpStreamBuffer.html#b7">releaseBoundBuffers</a>();
00721 
00722     <span class="keywordflow">return</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#b8">makeCurrent</a>();
00723 }
00724 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00725"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#a8">00725</a> <span class="keywordtype">bool</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#a8">SpStreamBuffer::disable</a>()
00726 {
00727     <span class="comment">// Ends rendering to the SpStreamBuffer.</span>
00728 
00729     <span class="keywordflow">if</span> (!<a class="code" href="classSpark_1_1SpStreamBuffer.html#p6">m_bInitialized</a>)
00730     {
00731         fprintf(stderr,
00732                 <span class="stringliteral">"SpStreamBuffer::disable() : Texture is not initialized!\n"</span>);
00733         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00734     }
00735 
00736     <a class="code" href="classSpark_1_1SpStreamBuffer.html#b6">captureBuffer</a>();
00737 
00738 <span class="preprocessor">#ifdef _WIN32</span>
00739 <span class="preprocessor"></span>    <span class="comment">// make the previous rendering context current</span>
00740     <span class="keywordflow">if</span> (FALSE == wglMakeCurrent( m_hPreviousDC, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p25">m_hPreviousContext</a>))
00741     {
00742         wglGetLastError();
00743         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00744     }
00745 <span class="preprocessor">#else</span>
00746 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (False == glXMakeCurrent(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p24">m_hPreviousDrawable</a>,
00747                                 <a class="code" href="classSpark_1_1SpStreamBuffer.html#p25">m_hPreviousContext</a>))
00748     {
00749         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00750     }
00751 <span class="preprocessor">#endif</span>
00752 <span class="preprocessor"></span>
00753     <span class="comment">// rebind the textures to a buffers for RTT</span>
00754     <a class="code" href="classSpark_1_1SpStreamBuffer.html#a11">bindBuffer</a>(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p9">m_iCurrentBoundBuffer</a>);
00755     <a class="code" href="classSpark_1_1SpStreamBuffer.html#b9">bindDepthBuffer</a>();
00756 
00757     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00758 }
00759 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00760"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#a7">00760</a> <span class="keywordtype">bool</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#a6">SpStreamBuffer::enable</a>(<a class="code" href="classSpark_1_1SpStreamBuffer.html">SpStreamBuffer</a>* pkCurrent)
00761 {
00762     <span class="comment">//</span>
00763     <span class="comment">// When performing a series of operations where you modify one texture after</span>
00764     <span class="comment">// another, it is more efficient to use this method instead of the equivalent</span>
00765     <span class="comment">// 'EndCapture'/'BeginCapture' pair.  This method switches directly to the</span>
00766     <span class="comment">// new context rather than changing to the default context, and then to the</span>
00767     <span class="comment">// new context.</span>
00768     <span class="comment">//</span>
00769     <span class="comment">// SpStreamBuffer doesn't have any mechanism for determining if</span>
00770     <span class="comment">// 'current' really is currently active, so no error will be thrown</span>
00771     <span class="comment">// if it is not.</span>
00772     <span class="comment">//</span>
00773 
00774     <span class="keywordtype">bool</span> bContextReset = <span class="keyword">false</span>;
00775 
00776     <span class="keywordflow">if</span> (pkCurrent == <span class="keyword">this</span>) {
00777         <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// no switch necessary</span>
00778     }
00779     <span class="keywordflow">if</span> (!pkCurrent) {
00780         <span class="comment">// treat as normal Begin if pkCurrent is 0.</span>
00781         <span class="keywordflow">return</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#a6">enable</a>();
00782     }
00783     <span class="keywordflow">if</span> (!<a class="code" href="classSpark_1_1SpStreamBuffer.html#p6">m_bInitialized</a>)
00784     {
00785         fprintf(stderr,
00786             <span class="stringliteral">"SpStreamBuffer::enable(SpStreamBuffer*): Texture is not initialized!\n"</span>);
00787         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00788     }
00789     <span class="keywordflow">if</span> (!pkCurrent-&gt;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p6">m_bInitialized</a>)
00790     {
00791         fprintf(stderr,
00792             <span class="stringliteral">"SpStreamBuffer::enable(SpStreamBuffer): 'Current' texture is not initialized!\n"</span>);
00793         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00794     }
00795 
00796     <span class="comment">// Sync pkCurrent pbuffer with its CTT texture if necessary</span>
00797     pkCurrent-&gt;<a class="code" href="classSpark_1_1SpStreamBuffer.html#b6">captureBuffer</a>();
00798 
00799     <span class="comment">// pass along the previous context so we can reset it when</span>
00800     <span class="comment">// disable() is called.</span>
00801 <span class="preprocessor">#ifdef _WIN32</span>
00802 <span class="preprocessor"></span>    m_hPreviousDC      = pkCurrent-&gt;m_hPreviousDC;
00803     <span class="keywordflow">if</span> (NULL == m_hPreviousDC)
00804         wglGetLastError();
00805     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p25">m_hPreviousContext</a> = pkCurrent-&gt;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p25">m_hPreviousContext</a>;
00806     <span class="keywordflow">if</span> (NULL == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p25">m_hPreviousContext</a>)
00807         wglGetLastError();
00808 <span class="preprocessor">#else</span>
00809 <span class="preprocessor"></span>    <a class="code" href="classSpark_1_1SpStreamBuffer.html#p25">m_hPreviousContext</a> = pkCurrent-&gt;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p25">m_hPreviousContext</a>;
00810     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p24">m_hPreviousDrawable</a> = pkCurrent-&gt;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p24">m_hPreviousDrawable</a>;
00811 <span class="preprocessor">#endif</span>
00812 <span class="preprocessor"></span>
00813     <span class="comment">// Unbind textures before making context pkCurrent</span>
00814     <span class="keywordflow">if</span> (!<a class="code" href="classSpark_1_1SpStreamBuffer.html#b7">releaseBoundBuffers</a>())
00815       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00816 
00817     <span class="comment">// Make the pbuffer context pkCurrent</span>
00818     <span class="keywordflow">if</span> (!<a class="code" href="classSpark_1_1SpStreamBuffer.html#b8">makeCurrent</a>())
00819         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00820 
00821     <span class="comment">// Rebind buffers of initial SpStreamBuffer</span>
00822     pkCurrent-&gt;<a class="code" href="classSpark_1_1SpStreamBuffer.html#a11">bindBuffer</a>(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p9">m_iCurrentBoundBuffer</a>);
00823     pkCurrent-&gt;<a class="code" href="classSpark_1_1SpStreamBuffer.html#b9">bindDepthBuffer</a>();
00824 
00825     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00826 }
00827 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00828"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#a9">00828</a> <span class="keywordtype">void</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#a9">SpStreamBuffer::bind</a>()<span class="keyword"> const</span>
00829 <span class="keyword"></span>{
00830     <span class="comment">// Binds RGB texture.</span>
00831 
00832     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p6">m_bInitialized</a> &amp;&amp; <a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a>)
00833     {
00834         glBindTexture(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p27">m_uiTextureId</a>);
00835     }
00836 }
00837 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00838"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#a10">00838</a> <span class="keywordtype">void</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#a10">SpStreamBuffer::bindDepth</a>()<span class="keyword"> const</span>
00839 <span class="keyword"></span>{
00840     <span class="comment">// Binds depth texture.</span>
00841 
00842     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p6">m_bInitialized</a> &amp;&amp; <a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a>)
00843     {
00844         glBindTexture(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p28">m_uiDepthTextureId</a>);
00845     }
00846 }
00847 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00848"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#a11">00848</a> <span class="keywordtype">bool</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#a11">SpStreamBuffer::bindBuffer</a>( <span class="keywordtype">int</span> iBuffer )
00849 {
00850     <span class="comment">// Associate the RTT texture id with 'iBuffer' (e.g. WGL_FRONT_LEFT_ARB)</span>
00851 
00852     <span class="comment">// Must bind the texture too</span>
00853     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p6">m_bInitialized</a> &amp;&amp; <a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a>)
00854     {
00855         glBindTexture(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p27">m_uiTextureId</a>);
00856 
00857 <span class="preprocessor">#if _WIN32</span>
00858 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#w2w0">RT_RENDER_TO_TEXTURE</a> == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a> &amp;&amp; <a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a> &amp;&amp;
00859             (!<a class="code" href="classSpark_1_1SpStreamBuffer.html#p8">m_bIsBufferBound</a> || <a class="code" href="classSpark_1_1SpStreamBuffer.html#p9">m_iCurrentBoundBuffer</a> != iBuffer))
00860         {
00861             <span class="keywordflow">if</span> (FALSE == wglBindTexImageARB(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>, iBuffer))
00862             {
00863                 <span class="comment">//  WVB: WGL API considers binding twice to the same buffer</span>
00864                 <span class="comment">//  to be an error.  But we don't want to</span>
00865                 <span class="comment">//wglGetLastError();</span>
00866                 <span class="comment">//return false;</span>
00867                 SetLastError(0);
00868             }
00869             <a class="code" href="classSpark_1_1SpStreamBuffer.html#p8">m_bIsBufferBound</a> = <span class="keyword">true</span>;
00870             <a class="code" href="classSpark_1_1SpStreamBuffer.html#p9">m_iCurrentBoundBuffer</a> = iBuffer;
00871         }
00872 <span class="preprocessor">#endif</span>
00873 <span class="preprocessor"></span>    }
00874     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00875 }
00876 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l00877"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#b9">00877</a> <span class="keywordtype">bool</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#b9">SpStreamBuffer::bindDepthBuffer</a>()<span class="keyword"> const</span>
00878 <span class="keyword"></span>{
00879     <span class="comment">// Associate the RTT depth texture id with the depth buffer</span>
00880 
00881 <span class="preprocessor">#ifdef WIN32</span>
00882 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p6">m_bInitialized</a> &amp;&amp; <a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a> &amp;&amp;
00883         <a class="code" href="classSpark_1_1SpStreamBuffer.html#w2w0">RT_RENDER_TO_TEXTURE</a> == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a>)
00884     {
00885         glBindTexture(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p28">m_uiDepthTextureId</a>);
00886         <span class="keywordflow">if</span> (FALSE == wglBindTexImageARB(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>, WGL_DEPTH_COMPONENT_NV))
00887         {
00888             wglGetLastError();
00889             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00890         }
00891     }
00892 <span class="preprocessor">#endif</span>
00893 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;
00894 }
00895 <span class="comment">// ---------------------------------------------------------------------------</span>
00896 <span class="keywordtype">void</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#b1">SpStreamBuffer::parseModeString</a>(
00897     <span class="keyword">const</span> <span class="keywordtype">char</span> *acModeString,
00898     vector&lt;int&gt; &amp;rkPixelFormatAttribs,
00899     vector&lt;int&gt; &amp;rkPixelBufferAttribs)
00900 {
00901     <span class="comment">// Parses the user-specified mode SpString for SpStreamBuffer parameters.</span>
00902 
00903     <span class="keywordflow">if</span> (!acModeString || strcmp(acModeString, <span class="stringliteral">""</span>) == 0)
00904         <span class="keywordflow">return</span>;
00905 
00906     m_uiComponents = 0;
00907     m_eUpdateMode = RT_RENDER_TO_TEXTURE;
00908 
00909     <span class="keywordtype">int</span>  iDepthBits = 0;
00910     <span class="keywordtype">bool</span> bHasStencil = <span class="keyword">false</span>;
00911     <span class="keywordtype">bool</span> bBind2D   = <span class="keyword">false</span>;
00912     <span class="keywordtype">bool</span> bBindRECT = <span class="keyword">false</span>;
00913     <span class="keywordtype">bool</span> bBindCUBE = <span class="keyword">false</span>;
00914 
00915     <span class="keywordtype">char</span> *acMode = strdup(acModeString);
00916 
00917 
00918     vector&lt;SpString&gt; kTokens;
00919     <span class="keywordtype">char</span> *acBuffer = strtok(acMode, <span class="stringliteral">" "</span>);
00920     <span class="keywordflow">while</span> (acBuffer != NULL)
00921     {
00922         kTokens.push_back(acBuffer);
00923         acBuffer = strtok(NULL, <span class="stringliteral">" "</span>);
00924     }
00925 
00926     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; kTokens.size(); i++)
00927     {
00928         <a class="code" href="classSpark_1_1SpString.html">SpString</a> kToken = kTokens[i];
00929 
00930         KeyVal kKeyValuePair = <a class="code" href="classSpark_1_1SpStreamBuffer.html#b3">getKeyValuePair</a>(kToken);
00931 
00932 
00933         <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"rgb"</span> &amp;&amp; (m_uiComponents &lt;= 1))
00934         {
00935             <span class="keywordflow">if</span> (kKeyValuePair.second.find(<span class="stringliteral">"f"</span>) != kKeyValuePair.second.npos)
00936                 m_bIsFloat = <span class="keyword">true</span>;
00937 
00938             vector&lt;int&gt; kBitVector = <a class="code" href="classSpark_1_1SpStreamBuffer.html#b2">parseBitVector</a>(kKeyValuePair.second);
00939 
00940             <span class="keywordflow">if</span> (kBitVector.size() &lt; 3) <span class="comment">// expand the scalar to a vector</span>
00941             {
00942                 kBitVector.push_back(kBitVector[0]);
00943                 kBitVector.push_back(kBitVector[0]);
00944             }
00945 
00946 <span class="preprocessor">#ifdef _WIN32</span>
00947 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(WGL_RED_BITS_ARB);
00948             rkPixelFormatAttribs.push_back(kBitVector[0]);
00949             rkPixelFormatAttribs.push_back(WGL_GREEN_BITS_ARB);
00950             rkPixelFormatAttribs.push_back(kBitVector[1]);
00951             rkPixelFormatAttribs.push_back(WGL_BLUE_BITS_ARB);
00952             rkPixelFormatAttribs.push_back(kBitVector[2]);
00953 <span class="preprocessor">#else</span>
00954 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(GLX_RED_SIZE);
00955             rkPixelFormatAttribs.push_back(kBitVector[0]);
00956             rkPixelFormatAttribs.push_back(GLX_GREEN_SIZE);
00957             rkPixelFormatAttribs.push_back(kBitVector[1]);
00958             rkPixelFormatAttribs.push_back(GLX_BLUE_SIZE);
00959             rkPixelFormatAttribs.push_back(kBitVector[2]);
00960 <span class="preprocessor">#endif</span>
00961 <span class="preprocessor"></span>            <a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a> += 3;
00962             <span class="keywordflow">continue</span>;
00963         }
00964         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"rgb"</span>)
00965             fprintf(stderr,
00966                     <span class="stringliteral">"SpStreamBuffer Warning: mistake in components definition "</span>
00967                     <span class="stringliteral">"(rgb + %d).\n"</span>,
00968                     m_uiComponents);
00969 
00970 
00971         <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"rgba"</span> &amp;&amp; (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a> == 0))
00972         {
00973             <span class="keywordflow">if</span> (kKeyValuePair.second.find(<span class="stringliteral">"f"</span>) != kKeyValuePair.second.npos)
00974                 <a class="code" href="classSpark_1_1SpStreamBuffer.html#p14">m_bIsFloat</a> = <span class="keyword">true</span>;
00975 
00976             vector&lt;int&gt; kBitVector = <a class="code" href="classSpark_1_1SpStreamBuffer.html#b2">parseBitVector</a>(kKeyValuePair.second);
00977 
00978             <span class="keywordflow">if</span> (kBitVector.size() &lt; 4) <span class="comment">// expand the scalar to a vector</span>
00979             {
00980                 kBitVector.push_back(kBitVector[0]);
00981                 kBitVector.push_back(kBitVector[0]);
00982                 kBitVector.push_back(kBitVector[0]);
00983             }
00984 
00985 <span class="preprocessor">#ifdef _WIN32</span>
00986 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(WGL_RED_BITS_ARB);
00987             rkPixelFormatAttribs.push_back(kBitVector[0]);
00988             rkPixelFormatAttribs.push_back(WGL_GREEN_BITS_ARB);
00989             rkPixelFormatAttribs.push_back(kBitVector[1]);
00990             rkPixelFormatAttribs.push_back(WGL_BLUE_BITS_ARB);
00991             rkPixelFormatAttribs.push_back(kBitVector[2]);
00992             rkPixelFormatAttribs.push_back(WGL_ALPHA_BITS_ARB);
00993             rkPixelFormatAttribs.push_back(kBitVector[3]);
00994 <span class="preprocessor">#else</span>
00995 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(GLX_RED_SIZE);
00996             rkPixelFormatAttribs.push_back(kBitVector[0]);
00997             rkPixelFormatAttribs.push_back(GLX_GREEN_SIZE);
00998             rkPixelFormatAttribs.push_back(kBitVector[1]);
00999             rkPixelFormatAttribs.push_back(GLX_BLUE_SIZE);
01000             rkPixelFormatAttribs.push_back(kBitVector[2]);
01001             rkPixelFormatAttribs.push_back(GLX_ALPHA_SIZE);
01002             rkPixelFormatAttribs.push_back(kBitVector[3]);
01003 <span class="preprocessor">#endif</span>
01004 <span class="preprocessor"></span>            <a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a> = 4;
01005             <span class="keywordflow">continue</span>;
01006         }
01007         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"rgba"</span>)
01008             fprintf(stderr,
01009                     <span class="stringliteral">"SpStreamBuffer Warning: mistake in components definition "</span>
01010                     <span class="stringliteral">"(rgba + %d).\n"</span>,
01011                     m_uiComponents);
01012 
01013         <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"r"</span> &amp;&amp; (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a> &lt;= 1))
01014         {
01015             <span class="keywordflow">if</span> (kKeyValuePair.second.find(<span class="stringliteral">"f"</span>) != kKeyValuePair.second.npos)
01016                 <a class="code" href="classSpark_1_1SpStreamBuffer.html#p14">m_bIsFloat</a> = <span class="keyword">true</span>;
01017 
01018             vector&lt;int&gt; kBitVector = <a class="code" href="classSpark_1_1SpStreamBuffer.html#b2">parseBitVector</a>(kKeyValuePair.second);
01019 
01020 <span class="preprocessor">#ifdef _WIN32</span>
01021 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(WGL_RED_BITS_ARB);
01022             rkPixelFormatAttribs.push_back(kBitVector[0]);
01023 <span class="preprocessor">#else</span>
01024 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(GLX_RED_SIZE);
01025             rkPixelFormatAttribs.push_back(kBitVector[0]);
01026 <span class="preprocessor">#endif</span>
01027 <span class="preprocessor"></span>            <a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a>++;
01028             <span class="keywordflow">continue</span>;
01029         }
01030         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"r"</span>)
01031             fprintf(stderr,
01032                     <span class="stringliteral">"SpStreamBuffer Warning: mistake in components definition "</span>
01033                     <span class="stringliteral">"(r + %d).\n"</span>,
01034                     m_uiComponents);
01035 
01036         <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"rg"</span> &amp;&amp; (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a> &lt;= 1))
01037         {
01038             <span class="keywordflow">if</span> (kKeyValuePair.second.find(<span class="stringliteral">"f"</span>) != kKeyValuePair.second.npos)
01039                 <a class="code" href="classSpark_1_1SpStreamBuffer.html#p14">m_bIsFloat</a> = <span class="keyword">true</span>;
01040 
01041             vector&lt;int&gt; kBitVector = <a class="code" href="classSpark_1_1SpStreamBuffer.html#b2">parseBitVector</a>(kKeyValuePair.second);
01042 
01043             <span class="keywordflow">if</span> (kBitVector.size() &lt; 2) <span class="comment">// expand the scalar to a vector</span>
01044             {
01045                 kBitVector.push_back(kBitVector[0]);
01046             }
01047 
01048 <span class="preprocessor">#ifdef _WIN32</span>
01049 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(WGL_RED_BITS_ARB);
01050             rkPixelFormatAttribs.push_back(kBitVector[0]);
01051             rkPixelFormatAttribs.push_back(WGL_GREEN_BITS_ARB);
01052             rkPixelFormatAttribs.push_back(kBitVector[1]);
01053 <span class="preprocessor">#else</span>
01054 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(GLX_RED_SIZE);
01055             rkPixelFormatAttribs.push_back(kBitVector[0]);
01056             rkPixelFormatAttribs.push_back(GLX_GREEN_SIZE);
01057             rkPixelFormatAttribs.push_back(kBitVector[1]);
01058 <span class="preprocessor">#endif</span>
01059 <span class="preprocessor"></span>            <a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a> += 2;
01060             <span class="keywordflow">continue</span>;
01061         }
01062         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"rg"</span>)
01063             fprintf(stderr,
01064                     <span class="stringliteral">"SpStreamBuffer Warning: mistake in components definition "</span>
01065                     <span class="stringliteral">"(rg + %d).\n"</span>,
01066                     m_uiComponents);
01067 
01068         <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"depth"</span>)
01069         {
01070             <span class="keywordflow">if</span> (kKeyValuePair.second == <span class="stringliteral">""</span>)
01071                 iDepthBits = 24;
01072             <span class="keywordflow">else</span>
01073                 iDepthBits = strtol(kKeyValuePair.second.c_str(), 0, 10);
01074             <span class="keywordflow">continue</span>;
01075         }
01076 
01077         <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"stencil"</span>)
01078         {
01079             bHasStencil = <span class="keyword">true</span>;
01080 <span class="preprocessor">#ifdef _WIN32</span>
01081 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(WGL_STENCIL_BITS_ARB);
01082 <span class="preprocessor">#else</span>
01083 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(GLX_STENCIL_SIZE);
01084 <span class="preprocessor">#endif</span>
01085 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (kKeyValuePair.second == <span class="stringliteral">""</span>)
01086                 rkPixelFormatAttribs.push_back(8);
01087             <span class="keywordflow">else</span>
01088                 rkPixelFormatAttribs.push_back(strtol(kKeyValuePair.second.c_str(), 0, 10));
01089             <span class="keywordflow">continue</span>;
01090         }
01091 
01092         <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"samples"</span>)
01093         {
01094 <span class="preprocessor">#ifdef _WIN32</span>
01095 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(WGL_SAMPLE_BUFFERS_ARB);
01096             rkPixelFormatAttribs.push_back(1);
01097             rkPixelFormatAttribs.push_back(WGL_SAMPLES_ARB);
01098             rkPixelFormatAttribs.push_back(strtol(kKeyValuePair.second.c_str(), 0, 10));
01099 <span class="preprocessor">#endif</span>
01100 <span class="preprocessor"></span>            <span class="keywordflow">continue</span>;
01101 
01102         }
01103 
01104         <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"doubleacBufferfer"</span> || kKeyValuePair.first == <span class="stringliteral">"double"</span>)
01105         {
01106 <span class="preprocessor">#ifdef _WIN32</span>
01107 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(WGL_DOUBLE_BUFFER_ARB);
01108             rkPixelFormatAttribs.push_back(<span class="keyword">true</span>);
01109 <span class="preprocessor">#else</span>
01110 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(GLX_DOUBLEBUFFER);
01111             rkPixelFormatAttribs.push_back(True);
01112 <span class="preprocessor">#endif</span>
01113 <span class="preprocessor"></span>            <span class="keywordflow">continue</span>;
01114         }
01115 
01116         <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"aux"</span>)
01117         {
01118 <span class="preprocessor">#ifdef _WIN32</span>
01119 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(WGL_AUX_BUFFERS_ARB);
01120 <span class="preprocessor">#else</span>
01121 <span class="preprocessor"></span>            rkPixelFormatAttribs.push_back(GLX_AUX_BUFFERS);
01122 <span class="preprocessor">#endif</span>
01123 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (kKeyValuePair.second == <span class="stringliteral">""</span>)
01124                 rkPixelFormatAttribs.push_back(0);
01125             <span class="keywordflow">else</span>
01126                 rkPixelFormatAttribs.push_back(strtol(kKeyValuePair.second.c_str(), 0, 10));
01127             <span class="keywordflow">continue</span>;
01128         }
01129 
01130         <span class="keywordflow">if</span> (kToken.find(<span class="stringliteral">"tex"</span>) == 0)
01131         {
01132             <a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a> = <span class="keyword">true</span>;
01133 
01134             <span class="keywordflow">if</span> ((kKeyValuePair.first == <span class="stringliteral">"texRECT"</span>) &amp;&amp; GLEW_NV_texture_rectangle)
01135             {
01136                 <a class="code" href="classSpark_1_1SpStreamBuffer.html#p17">m_bIsRectangle</a> = <span class="keyword">true</span>;
01137                 bBindRECT = <span class="keyword">true</span>;
01138             }
01139             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"texCUBE"</span>)
01140             {
01141                 bBindCUBE = <span class="keyword">true</span>;
01142             }
01143             <span class="keywordflow">else</span>
01144             {
01145                 bBind2D = <span class="keyword">true</span>;
01146             }
01147 
01148             <span class="keywordflow">continue</span>;
01149         }
01150 
01151         <span class="keywordflow">if</span> (kToken.find(<span class="stringliteral">"depthTex"</span>) == 0)
01152         {
01153             <a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a> = <span class="keyword">true</span>;
01154 
01155             <span class="keywordflow">if</span> ((kKeyValuePair.first == <span class="stringliteral">"depthTexRECT"</span>) &amp;&amp; GLEW_NV_texture_rectangle)
01156             {
01157                 <a class="code" href="classSpark_1_1SpStreamBuffer.html#p17">m_bIsRectangle</a> = <span class="keyword">true</span>;
01158                 bBindRECT = <span class="keyword">true</span>;
01159             }
01160             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"depthTexCUBE"</span>)
01161             {
01162                 bBindCUBE = <span class="keyword">true</span>;
01163             }
01164             <span class="keywordflow">else</span>
01165             {
01166                 bBind2D = <span class="keyword">true</span>;
01167             }
01168 
01169             <span class="keywordflow">continue</span>;
01170         }
01171 
01172         <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"mipmap"</span>)
01173         {
01174             <a class="code" href="classSpark_1_1SpStreamBuffer.html#p18">m_bIsMipMapped</a> = <span class="keyword">true</span>;
01175             <span class="keywordflow">continue</span>;
01176         }
01177 
01178         <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"rtt"</span>)
01179         {
01180             <a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a> = RT_RENDER_TO_TEXTURE;
01181             <span class="keywordflow">continue</span>;
01182         }
01183 
01184         <span class="keywordflow">if</span> (kKeyValuePair.first == <span class="stringliteral">"ctt"</span>)
01185         {
01186             <a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a> = <a class="code" href="classSpark_1_1SpStreamBuffer.html#w2w1">RT_COPY_TO_TEXTURE</a>;
01187             <span class="keywordflow">continue</span>;
01188         }
01189 
01190         fprintf(stderr,
01191                 <span class="stringliteral">"SpStreamBuffer Error: Unknown pacBufferfer attribute: %s\n"</span>,
01192                 kToken.c_str());
01193     }
01194 
01195     <span class="comment">// Processing of some options must be last because of interactions.</span>
01196 
01197     <span class="comment">// Check for inconsistent texture targets</span>
01198     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a> &amp;&amp; <a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a> &amp;&amp; !(bBind2D ^ bBindRECT ^ bBindCUBE))
01199     {
01200         fprintf(stderr,
01201                 <span class="stringliteral">"SpStreamBuffer Warning: Depth and Color texture targets "</span>
01202                 <span class="stringliteral">"should match.\n"</span>);
01203     }
01204 
01205     <span class="comment">// Apply default bit format if none specified</span>
01206 <span class="preprocessor">#ifdef _WIN32</span>
01207 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (0 == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a>)
01208     {
01209         rkPixelFormatAttribs.push_back(WGL_RED_BITS_ARB);
01210         rkPixelFormatAttribs.push_back(8);
01211         rkPixelFormatAttribs.push_back(WGL_GREEN_BITS_ARB);
01212         rkPixelFormatAttribs.push_back(8);
01213         rkPixelFormatAttribs.push_back(WGL_BLUE_BITS_ARB);
01214         rkPixelFormatAttribs.push_back(8);
01215         rkPixelFormatAttribs.push_back(WGL_ALPHA_BITS_ARB);
01216         rkPixelFormatAttribs.push_back(8);
01217         <a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a> = 4;
01218     }
01219 <span class="preprocessor">#endif</span>
01220 <span class="preprocessor"></span>
01221     <span class="comment">// Depth bits</span>
01222     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a> &amp;&amp; !iDepthBits)
01223         iDepthBits = 24;
01224 
01225 <span class="preprocessor">#ifdef _WIN32</span>
01226 <span class="preprocessor"></span>    rkPixelFormatAttribs.push_back(WGL_DEPTH_BITS_ARB);
01227 <span class="preprocessor">#else</span>
01228 <span class="preprocessor"></span>    rkPixelFormatAttribs.push_back(GLX_DEPTH_SIZE);
01229 <span class="preprocessor">#endif</span>
01230 <span class="preprocessor"></span>    rkPixelFormatAttribs.push_back(iDepthBits); <span class="comment">// default</span>
01231 
01232     <span class="keywordflow">if</span> (!bHasStencil)
01233     {
01234 <span class="preprocessor">#ifdef _WIN32</span>
01235 <span class="preprocessor"></span>        rkPixelFormatAttribs.push_back(WGL_STENCIL_BITS_ARB);
01236         rkPixelFormatAttribs.push_back(0);
01237 <span class="preprocessor">#else</span>
01238 <span class="preprocessor"></span>        rkPixelFormatAttribs.push_back(GLX_STENCIL_SIZE);
01239         rkPixelFormatAttribs.push_back(0);
01240 <span class="preprocessor">#endif</span>
01241 <span class="preprocessor"></span>
01242     }
01243     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a> &lt; 4)
01244     {
01245         <span class="comment">// Can't do this right now -- on NVIDIA drivers, currently get</span>
01246         <span class="comment">// a non-functioning pacBufferfer if ALPHA_BITS=0 and</span>
01247         <span class="comment">// WGL_BIND_TO_TEXTURE_RGB_ARB=true</span>
01248 
01249         <span class="comment">//rkPixelFormatAttribs.push_back(WGL_ALPHA_BITS_ARB);</span>
01250         <span class="comment">//rkPixelFormatAttribs.push_back(0);</span>
01251     }
01252 
01253 <span class="preprocessor">#ifdef _WIN32</span>
01254 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!WGLEW_NV_render_depth_texture &amp;&amp; <a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a> &amp;&amp; (RT_RENDER_TO_TEXTURE == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a>))
01255     {
01256 <span class="preprocessor">#if defined(DEBUG) || defined(_DEBUG)</span>
01257 <span class="preprocessor"></span>        fprintf(stderr, <span class="stringliteral">"SpStreamBuffer Warning: No support found for "</span>
01258                 <span class="stringliteral">"render to depth texture.\n"</span>);
01259 <span class="preprocessor">#endif</span>
01260 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01261 <span class="preprocessor"></span>        <a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a> = <span class="keyword">false</span>;
01262 <span class="preprocessor">#ifdef _WIN32</span>
01263 <span class="preprocessor"></span>    }
01264 <span class="preprocessor">#endif</span>
01265 <span class="preprocessor"></span>
01266     <span class="keywordflow">if</span> ((<a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a> || <a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a>) &amp;&amp;
01267         (RT_RENDER_TO_TEXTURE == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a>))
01268     {
01269 <span class="preprocessor">#ifdef _WIN32</span>
01270 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (bBindRECT)
01271         {
01272             rkPixelBufferAttribs.push_back(WGL_TEXTURE_TARGET_ARB);
01273             rkPixelBufferAttribs.push_back(WGL_TEXTURE_RECTANGLE_NV);
01274         }
01275         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bBindCUBE)
01276         {
01277             rkPixelBufferAttribs.push_back(WGL_TEXTURE_TARGET_ARB);
01278             rkPixelBufferAttribs.push_back(WGL_TEXTURE_CUBE_MAP_ARB);
01279         }
01280         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bBind2D)
01281         {
01282             rkPixelBufferAttribs.push_back(WGL_TEXTURE_TARGET_ARB);
01283             rkPixelBufferAttribs.push_back(WGL_TEXTURE_2D_ARB);
01284         }
01285 
01286         <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p18">m_bIsMipMapped</a>)
01287         {
01288             rkPixelBufferAttribs.push_back(WGL_MIPMAP_TEXTURE_ARB);
01289             rkPixelBufferAttribs.push_back(<span class="keyword">true</span>);
01290         }
01291 
01292 <span class="preprocessor">#elif defined(DEBUG) || defined(_DEBUG)</span>
01293 <span class="preprocessor"></span>        printf(<span class="stringliteral">"SpStreamBuffer Error: Render to Texture not "</span>
01294                <span class="stringliteral">"supported in Linux\n"</span>);
01295 <span class="preprocessor">#endif</span>
01296 <span class="preprocessor"></span>    }
01297 
01298     <span class="comment">// Set the pixel type</span>
01299     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p14">m_bIsFloat</a>)
01300     {
01301 <span class="preprocessor">#ifdef _WIN32</span>
01302 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (WGLEW_NV_float_buffer)
01303         {
01304             rkPixelFormatAttribs.push_back(WGL_PIXEL_TYPE_ARB);
01305             rkPixelFormatAttribs.push_back(WGL_TYPE_RGBA_ARB);
01306 
01307             rkPixelFormatAttribs.push_back(WGL_FLOAT_COMPONENTS_NV);
01308             rkPixelFormatAttribs.push_back(<span class="keyword">true</span>);
01309         }
01310         <span class="keywordflow">else</span>
01311         {
01312             rkPixelFormatAttribs.push_back(WGL_PIXEL_TYPE_ARB);
01313             rkPixelFormatAttribs.push_back(WGL_TYPE_RGBA_FLOAT_ATI);
01314         }
01315 <span class="preprocessor">#else</span>
01316 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (GLXEW_NV_float_acBufferfer)
01317         {
01318             rkPixelFormatAttribs.push_back(GLX_FLOAT_COMPONENTS_NV);
01319             rkPixelFormatAttribs.push_back(1);
01320         }
01321 <span class="preprocessor">#endif</span>
01322 <span class="preprocessor"></span>    }
01323     <span class="keywordflow">else</span>
01324     {
01325 <span class="preprocessor">#ifdef _WIN32</span>
01326 <span class="preprocessor"></span>        rkPixelFormatAttribs.push_back(WGL_PIXEL_TYPE_ARB);
01327         rkPixelFormatAttribs.push_back(WGL_TYPE_RGBA_ARB);
01328 <span class="preprocessor">#endif</span>
01329 <span class="preprocessor"></span>    }
01330 
01331     <span class="comment">// Set up texture binding for render to texture</span>
01332     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a> &amp;&amp; (RT_RENDER_TO_TEXTURE == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a>))
01333     {
01334 
01335 <span class="preprocessor">#ifdef _WIN32</span>
01336 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p14">m_bIsFloat</a>)
01337         {
01338             <span class="keywordflow">if</span> (WGLEW_NV_float_buffer)
01339             {
01340                 <span class="keywordflow">switch</span>(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a>)
01341                 {
01342                 <span class="keywordflow">case</span> 1:
01343                     rkPixelFormatAttribs.push_back(WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV);
01344                     rkPixelFormatAttribs.push_back(<span class="keyword">true</span>);
01345 
01346                     rkPixelBufferAttribs.push_back(WGL_TEXTURE_FORMAT_ARB);
01347                     rkPixelBufferAttribs.push_back(WGL_TEXTURE_FLOAT_R_NV);
01348                     <span class="keywordflow">break</span>;
01349                 <span class="keywordflow">case</span> 2:
01350                     rkPixelFormatAttribs.push_back(WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV);
01351                     rkPixelFormatAttribs.push_back(<span class="keyword">true</span>);
01352 
01353                     rkPixelBufferAttribs.push_back(WGL_TEXTURE_FORMAT_ARB);
01354                     rkPixelBufferAttribs.push_back(WGL_TEXTURE_FLOAT_RG_NV);
01355                     <span class="keywordflow">break</span>;
01356                 <span class="keywordflow">case</span> 3:
01357                     rkPixelFormatAttribs.push_back(WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV);
01358                     rkPixelFormatAttribs.push_back(<span class="keyword">true</span>);
01359 
01360                     rkPixelBufferAttribs.push_back(WGL_TEXTURE_FORMAT_ARB);
01361                     rkPixelBufferAttribs.push_back(WGL_TEXTURE_FLOAT_RGB_NV);
01362                     <span class="keywordflow">break</span>;
01363                 <span class="keywordflow">case</span> 4:
01364                     rkPixelFormatAttribs.push_back(WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV);
01365                     rkPixelFormatAttribs.push_back(<span class="keyword">true</span>);
01366 
01367                     rkPixelBufferAttribs.push_back(WGL_TEXTURE_FORMAT_ARB);
01368                     rkPixelBufferAttribs.push_back(WGL_TEXTURE_FLOAT_RGBA_NV);
01369                     <span class="keywordflow">break</span>;
01370                 <span class="keywordflow">default</span>:
01371                     fprintf(stderr,
01372                             <span class="stringliteral">"SpStreamBuffer Warning: Bad number of components "</span>
01373                             <span class="stringliteral">"(r=1,rg=2,rgb=3,rgba=4): %d.\n"</span>,
01374                             m_uiComponents);
01375                     <span class="keywordflow">break</span>;
01376                 }
01377             }
01378             <span class="keywordflow">else</span>
01379             {
01380                 <span class="keywordflow">if</span> (4 == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a>)
01381                 {
01382                     rkPixelFormatAttribs.push_back(WGL_BIND_TO_TEXTURE_RGBA_ARB);
01383                     rkPixelFormatAttribs.push_back(<span class="keyword">true</span>);
01384 
01385                     rkPixelBufferAttribs.push_back(WGL_TEXTURE_FORMAT_ARB);
01386                     rkPixelBufferAttribs.push_back(WGL_TEXTURE_RGBA_ARB);
01387                 }
01388                 <span class="keywordflow">else</span>
01389                 {
01390                     <span class="comment">// standard ARB_render_texture only supports 3 or 4 channels</span>
01391                     rkPixelFormatAttribs.push_back(WGL_BIND_TO_TEXTURE_RGB_ARB);
01392                     rkPixelFormatAttribs.push_back(<span class="keyword">true</span>);
01393 
01394                     rkPixelBufferAttribs.push_back(WGL_TEXTURE_FORMAT_ARB);
01395                     rkPixelBufferAttribs.push_back(WGL_TEXTURE_RGB_ARB);
01396                 }
01397             }
01398 
01399         }
01400         <span class="keywordflow">else</span>
01401         {
01402             <span class="keywordflow">switch</span>(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a>)
01403             {
01404             <span class="keywordflow">case</span> 3:
01405                 rkPixelFormatAttribs.push_back(WGL_BIND_TO_TEXTURE_RGB_ARB);
01406                 rkPixelFormatAttribs.push_back(<span class="keyword">true</span>);
01407 
01408                 rkPixelBufferAttribs.push_back(WGL_TEXTURE_FORMAT_ARB);
01409                 rkPixelBufferAttribs.push_back(WGL_TEXTURE_RGB_ARB);
01410                 <span class="keywordflow">break</span>;
01411             <span class="keywordflow">case</span> 4:
01412                 rkPixelFormatAttribs.push_back(WGL_BIND_TO_TEXTURE_RGBA_ARB);
01413                 rkPixelFormatAttribs.push_back(<span class="keyword">true</span>);
01414 
01415                 rkPixelBufferAttribs.push_back(WGL_TEXTURE_FORMAT_ARB);
01416                 rkPixelBufferAttribs.push_back(WGL_TEXTURE_RGBA_ARB);
01417                 <span class="keywordflow">break</span>;
01418             <span class="keywordflow">default</span>:
01419                 fprintf(stderr,
01420                         <span class="stringliteral">"SpStreamBuffer Warning: Bad number of components "</span>
01421                         <span class="stringliteral">"(r=1,rg=2,rgb=3,rgba=4): %d.\n"</span>, m_uiComponents);
01422                 <span class="keywordflow">break</span>;
01423             }
01424         }
01425 <span class="preprocessor">#elif defined(DEBUG) || defined(_DEBUG)</span>
01426 <span class="preprocessor"></span>        fprintf(stderr,
01427                 <span class="stringliteral">"SpStreamBuffer Error: Render to Texture not supported in "</span>
01428                 <span class="stringliteral">"Linux\n"</span>);
01429 <span class="preprocessor">#endif</span>
01430 <span class="preprocessor"></span>    }
01431 
01432     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a> &amp;&amp; (RT_RENDER_TO_TEXTURE == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a>))
01433     {
01434 <span class="preprocessor">#ifdef _WIN32</span>
01435 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p17">m_bIsRectangle</a>)
01436         {
01437             rkPixelFormatAttribs.push_back(WGL_BIND_TO_TEXTURE_RECTANGLE_DEPTH_NV);
01438             rkPixelFormatAttribs.push_back(<span class="keyword">true</span>);
01439 
01440             rkPixelBufferAttribs.push_back(WGL_DEPTH_TEXTURE_FORMAT_NV);
01441             rkPixelBufferAttribs.push_back(WGL_TEXTURE_DEPTH_COMPONENT_NV);
01442         }
01443         <span class="keywordflow">else</span>
01444         {
01445             rkPixelFormatAttribs.push_back(WGL_BIND_TO_TEXTURE_DEPTH_NV);
01446             rkPixelFormatAttribs.push_back(<span class="keyword">true</span>);
01447 
01448             rkPixelBufferAttribs.push_back(WGL_DEPTH_TEXTURE_FORMAT_NV);
01449             rkPixelBufferAttribs.push_back(WGL_TEXTURE_DEPTH_COMPONENT_NV);
01450         }
01451 <span class="preprocessor">#elif defined(DEBUG) || defined(_DEBUG)</span>
01452 <span class="preprocessor"></span>        printf(<span class="stringliteral">"SpStreamBuffer Error: Render to Texture not supported in "</span>
01453                <span class="stringliteral">"Linux\n"</span>);
01454 <span class="preprocessor">#endif</span>
01455 <span class="preprocessor"></span>    }
01456 }
01457 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l01458"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#b3">01458</a> <a class="code" href="classSpark_1_1SpStreamBuffer.html#x0">SpStreamBuffer::KeyVal</a> <a class="code" href="classSpark_1_1SpStreamBuffer.html#b3">SpStreamBuffer::getKeyValuePair</a>(<a class="code" href="classSpark_1_1SpString.html">SpString</a> kToken)
01459 {
01460     <span class="comment">// Parses expressions of the form "X=Y" into a pair (X,Y).</span>
01461 
01462     SpString::size_type kCurrent = 0;
01463     <span class="keywordflow">if</span> ((kCurrent = kToken.find(<span class="stringliteral">"="</span>)) != kToken.npos)
01464     {
01465         <a class="code" href="classSpark_1_1SpString.html">SpString</a> kKey = kToken.substr(0, kCurrent);
01466         <a class="code" href="classSpark_1_1SpString.html">SpString</a> kValue = kToken.substr(kCurrent+1, kToken.length()-kCurrent+1);
01467         <span class="keywordflow">return</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#x0">KeyVal</a>(kKey, kValue);
01468     }
01469     <span class="keywordflow">else</span>
01470         <span class="keywordflow">return</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#x0">KeyVal</a>(kToken, <span class="stringliteral">""</span>);
01471 }
01472 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l01473"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#b2">01473</a> vector&lt;int&gt; <a class="code" href="classSpark_1_1SpStreamBuffer.html#b2">SpStreamBuffer::parseBitVector</a>(<a class="code" href="classSpark_1_1SpString.html">SpString</a> kBitVector)
01474 {
01475     <span class="comment">// Parses expressions of the form "=r,g,b,a" into a vector: (r,g,b,a)</span>
01476 
01477     vector&lt;SpString&gt; kPieces;
01478     vector&lt;int&gt; kBits;
01479 
01480     <span class="keywordflow">if</span> (kBitVector == <span class="stringliteral">""</span>)
01481     {
01482         kBits.push_back(8);  <span class="comment">// if a depth isn't specified, use default 8 kBits</span>
01483         <span class="keywordflow">return</span> kBits;
01484     }
01485 
01486     <a class="code" href="classSpark_1_1SpString.html#w0">SpString::SizeType</a> kCurrent = 0;
01487     <a class="code" href="classSpark_1_1SpString.html#w0">SpString::SizeType</a> kNext = 0;
01488     <span class="keywordflow">do</span>
01489     {
01490         kNext = kBitVector.find_first_of(<span class="stringliteral">", \n"</span>, kCurrent);
01491         kPieces.push_back(<a class="code" href="classSpark_1_1SpString.html">SpString</a>(kBitVector, kCurrent, kNext - kCurrent));
01492         kCurrent = kNext+1;
01493     } <span class="keywordflow">while</span> (kNext != kBitVector.npos );
01494 
01495     <span class="keywordflow">for</span> ( vector&lt;SpString&gt;::iterator it = kPieces.begin(); it != kPieces.end(); it++)
01496     {
01497         kBits.push_back(strtol(it-&gt;c_str(), 0, 10));
01498     }
01499 
01500     <span class="keywordflow">return</span> kBits;
01501 }
01502 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l01503"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#b4">01503</a> <span class="keywordtype">bool</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#b4">SpStreamBuffer::verifyExtensions</a>()
01504 {
01505     <span class="comment">// Checks that the necessary extensions are available based on RT mode.</span>
01506 
01507 <span class="preprocessor">#ifdef _WIN32</span>
01508 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!WGLEW_ARB_pbuffer)
01509     {
01510         <a class="code" href="SpStreamBuffer_8cpp.html#a0">PrintExtensionError</a>(<span class="stringliteral">"WGL_ARB_pbuffer"</span>);
01511         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01512     }
01513     <span class="keywordflow">if</span> (!WGLEW_ARB_pixel_format)
01514     {
01515         <a class="code" href="SpStreamBuffer_8cpp.html#a0">PrintExtensionError</a>(<span class="stringliteral">"WGL_ARB_pixel_format"</span>);
01516         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01517     }
01518     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a> &amp;&amp; !WGLEW_ARB_render_texture)
01519     {
01520         <a class="code" href="SpStreamBuffer_8cpp.html#a0">PrintExtensionError</a>(<span class="stringliteral">"WGL_ARB_render_texture"</span>);
01521         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01522     }
01523     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p17">m_bIsRectangle</a> &amp;&amp; !GLEW_NV_texture_rectangle)
01524     {
01525         <a class="code" href="SpStreamBuffer_8cpp.html#a0">PrintExtensionError</a>(<span class="stringliteral">"GL_NV_texture_rectangle"</span>);
01526         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01527     }
01528     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p14">m_bIsFloat</a> &amp;&amp; !(GLEW_NV_float_buffer || WGLEW_ATI_pixel_format_float))
01529     {
01530         <a class="code" href="SpStreamBuffer_8cpp.html#a0">PrintExtensionError</a>(<span class="stringliteral">"GL_NV_float_buffer or GL_ATI_pixel_format_float"</span>);
01531         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01532 
01533     }
01534     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p14">m_bIsFloat</a> &amp;&amp; <a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a> &amp;&amp; !(GLEW_NV_float_buffer || GLEW_ATI_texture_float))
01535     {
01536         <a class="code" href="SpStreamBuffer_8cpp.html#a0">PrintExtensionError</a>(<span class="stringliteral">"NV_float_buffer or ATI_texture_float"</span>);
01537     }
01538     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a> &amp;&amp; !GLEW_ARB_depth_texture)
01539     {
01540         <span class="comment">// [Redge]</span>
01541 <span class="preprocessor">#if defined(_DEBUG) | defined(DEBUG)</span>
01542 <span class="preprocessor"></span>        fprintf(stderr,
01543                 <span class="stringliteral">"SpStreamBuffer Warning: "</span>
01544                 <span class="stringliteral">"OpenGL extension GL_ARB_depth_texture not available.\n"</span>
01545                 <span class="stringliteral">"         Using glReadPixels() to emulate behavior.\n"</span>);
01546 <span class="preprocessor">#endif</span>
01547 <span class="preprocessor"></span>        <a class="code" href="classSpark_1_1SpStreamBuffer.html#p4">m_bHasARBDepthTexture</a> = <span class="keyword">false</span>;
01548         <span class="comment">//PrintExtensionError("GL_ARB_depth_texture");</span>
01549         <span class="comment">//return false;</span>
01550         <span class="comment">// [/Redge]</span>
01551     }
01552     SetLastError(0);
01553 <span class="preprocessor">#else</span>
01554 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!GLXEW_SGIX_pbuffer)
01555     {
01556         <a class="code" href="SpStreamBuffer_8cpp.html#a0">PrintExtensionError</a>(<span class="stringliteral">"GLX_SGIX_pbuffer"</span>);
01557         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01558     }
01559     <span class="keywordflow">if</span> (!GLXEW_SGIX_fbconfig)
01560     {
01561         <a class="code" href="SpStreamBuffer_8cpp.html#a0">PrintExtensionError</a>(<span class="stringliteral">"GLX_SGIX_fbconfig"</span>);
01562         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01563     }
01564     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a>)
01565     {
01566         <a class="code" href="SpStreamBuffer_8cpp.html#a0">PrintExtensionError</a>(<span class="stringliteral">"I don't know: FIXME!"</span>);
01567         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01568     }
01569     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p14">m_bIsFloat</a> &amp;&amp; <a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a> &amp;&amp; !GLXEW_NV_float_buffer)
01570     {
01571         <a class="code" href="SpStreamBuffer_8cpp.html#a0">PrintExtensionError</a>(<span class="stringliteral">"GLX_NV_float_buffer"</span>);
01572         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01573     }
01574     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a> == RT_RENDER_TO_TEXTURE)
01575     {
01576         <a class="code" href="SpStreamBuffer_8cpp.html#a0">PrintExtensionError</a>(<span class="stringliteral">"Some GLX render texture extension: FIXME!"</span>);
01577         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01578     }
01579 <span class="preprocessor">#endif</span>
01580 <span class="preprocessor"></span>
01581     <span class="keywordflow">return</span> <span class="keyword">true</span>;
01582 }
01583 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l01584"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#b5">01584</a> <span class="keywordtype">bool</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#b5">SpStreamBuffer::initializeTextures</a>()
01585 {
01586     <span class="comment">// Initializes the state of textures used by the SpStreamBuffer.</span>
01587 
01588     <span class="comment">// Determine the appropriate texture formats and filtering modes.</span>
01589     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a> || <a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a>)
01590     {
01591         <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p17">m_bIsRectangle</a> &amp;&amp; GLEW_NV_texture_rectangle)
01592             <a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a> = GL_TEXTURE_RECTANGLE_NV;
01593         <span class="keywordflow">else</span>
01594             <a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a> = GL_TEXTURE_2D;
01595     }
01596 
01597     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a>)
01598     {
01599         glGenTextures(1, &amp;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p27">m_uiTextureId</a>);
01600         glBindTexture(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p27">m_uiTextureId</a>);
01601 
01602         <span class="comment">// Use clamp to edge as the default texture wrap mode for all tex</span>
01603         glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
01604         glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
01605         <span class="comment">// Use NEAREST as the default texture filtering mode.</span>
01606         glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
01607         glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
01608 
01609 
01610         <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#w2w1">RT_COPY_TO_TEXTURE</a> == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a>)
01611         {
01612             GLuint iInternalFormat;
01613             GLuint iFormat;
01614 
01615             <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p14">m_bIsFloat</a>)
01616             {
01617                 <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p18">m_bIsMipMapped</a>)
01618                 {
01619                     fprintf(stderr,
01620                         <span class="stringliteral">"SpStreamBuffer Error: mipmapped float textures not "</span>
01621                         <span class="stringliteral">"supported.\n"</span>);
01622                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01623                 }
01624 
01625                 <span class="keywordflow">switch</span>(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a>)
01626                 {
01627                 <span class="keywordflow">case</span> 1:
01628                     <span class="keywordflow">if</span> (GLEW_NV_float_buffer)
01629                     {
01630                         iInternalFormat = (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[0] &gt; 16) ?
01631                             GL_FLOAT_R32_NV : GL_FLOAT_R16_NV;
01632                     }
01633                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (GLEW_ATI_texture_float)
01634                     {
01635                         iInternalFormat = (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[0] &gt; 16) ?
01636                             GL_LUMINANCE_FLOAT32_ATI :
01637                             GL_LUMINANCE_FLOAT16_ATI;
01638                     }
01639                     iFormat = GL_LUMINANCE;
01640                     <span class="keywordflow">break</span>;
01641                 <span class="keywordflow">case</span> 2:
01642                     <span class="keywordflow">if</span> (GLEW_NV_float_buffer)
01643                     {
01644                         iInternalFormat = (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[0] &gt; 16) ?
01645                             GL_FLOAT_RG32_NV : GL_FLOAT_RG16_NV;
01646                     }
01647                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (GLEW_ATI_texture_float)
01648                     {
01649                         iInternalFormat = (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[0] &gt; 16) ?
01650                             GL_LUMINANCE_ALPHA_FLOAT32_ATI :
01651                             GL_LUMINANCE_ALPHA_FLOAT16_ATI;
01652                     }
01653                     iFormat = GL_LUMINANCE_ALPHA;
01654                     <span class="keywordflow">break</span>;
01655                 <span class="keywordflow">case</span> 3:
01656                     <span class="keywordflow">if</span> (GLEW_NV_float_buffer)
01657                     {
01658                         iInternalFormat = (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[0] &gt; 16) ?
01659                             GL_FLOAT_RGB32_NV : GL_FLOAT_RGB16_NV;
01660                     }
01661                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (GLEW_ATI_texture_float)
01662                     {
01663                         iInternalFormat = (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[0] &gt; 16) ?
01664                             GL_RGB_FLOAT32_ATI : GL_RGB_FLOAT16_ATI;
01665                     }
01666                     iFormat = GL_RGB;
01667                     <span class="keywordflow">break</span>;
01668                 <span class="keywordflow">case</span> 4:
01669                     <span class="keywordflow">if</span> (GLEW_NV_float_buffer)
01670                     {
01671                         iInternalFormat = (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[0] &gt; 16) ?
01672                             GL_FLOAT_RGBA32_NV : GL_FLOAT_RGBA16_NV;
01673                     }
01674                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (GLEW_ATI_texture_float)
01675                     {
01676                         iInternalFormat = (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p11">m_uiColorBits</a>[0] &gt; 16) ?
01677                             GL_RGBA_FLOAT32_ATI : GL_RGBA_FLOAT16_ATI;
01678                     }
01679                     iFormat = GL_RGBA;
01680                     <span class="keywordflow">break</span>;
01681                 <span class="keywordflow">default</span>:
01682                     printf(<span class="stringliteral">"SpStreamBuffer Error: "</span>
01683                            <span class="stringliteral">"Invalid number of components: %d\n"</span>,
01684                            <a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a>);
01685                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01686                 }
01687             }
01688             <span class="keywordflow">else</span> <span class="comment">// non-float</span>
01689             {
01690                 <span class="keywordflow">if</span> (4 == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p10">m_uiComponents</a>)
01691                 {
01692                     iInternalFormat = GL_RGBA8;
01693                     iFormat = GL_RGBA;
01694                 }
01695                 <span class="keywordflow">else</span>
01696                 {
01697                     iInternalFormat = GL_RGB8;
01698                     iFormat = GL_RGB;
01699                 }
01700             }
01701 
01702             <span class="comment">// Allocate the texture image (but pass it no data for now).</span>
01703             glTexImage2D(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, 0, iInternalFormat,
01704                          <a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a>, 0, iFormat, GL_FLOAT, NULL);
01705         }
01706     }
01707 
01708     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a>)
01709     {
01710         glGenTextures(1, &amp;<a class="code" href="classSpark_1_1SpStreamBuffer.html#p28">m_uiDepthTextureId</a>);
01711         glBindTexture(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p28">m_uiDepthTextureId</a>);
01712 
01713         <span class="comment">// Use clamp to edge as the default texture wrap mode for all tex</span>
01714         glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
01715         glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
01716         <span class="comment">// Use NEAREST as the default texture filtering mode.</span>
01717         glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
01718         glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
01719 
01720         <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#w2w1">RT_COPY_TO_TEXTURE</a> == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a>)
01721         {
01722             <span class="comment">// [Redge]</span>
01723             <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p4">m_bHasARBDepthTexture</a>)
01724             {
01725                 <span class="comment">// Allocate the texture image (but pass it no data for now).</span>
01726                 glTexImage2D(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, 0, GL_DEPTH_COMPONENT,
01727                              <a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a>, 0, GL_DEPTH_COMPONENT,
01728                              GL_FLOAT, NULL);
01729             }
01730             <span class="keywordflow">else</span>
01731             {
01732                 <span class="comment">// allocate memory for depth texture</span>
01733                 <span class="comment">// Since this is slow, we warn the user in debug mode. (above)</span>
01734                 <a class="code" href="classSpark_1_1SpStreamBuffer.html#p29">m_ausPoorDepthTexture</a> = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>[<a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a> * <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a>];
01735                 glTexImage2D(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, 0, GL_LUMINANCE16,
01736                              <a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a>, 0, GL_LUMINANCE,
01737                              GL_UNSIGNED_SHORT, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p29">m_ausPoorDepthTexture</a>);
01738             }
01739             <span class="comment">// [/Redge]</span>
01740         }
01741     }
01742 
01743     <span class="keywordflow">return</span> <span class="keyword">true</span>;
01744 }
01745 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l01746"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#b6">01746</a> <span class="keywordtype">void</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#b6">SpStreamBuffer::captureBuffer</a>()
01747 {
01748     <span class="comment">// Does the actual copying for RenderTextures with RT_COPY_TO_TEXTURE</span>
01749 
01750 <span class="preprocessor">#ifdef _WIN32</span>
01751 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#w2w1">RT_COPY_TO_TEXTURE</a> == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a>)
01752     {
01753         <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a>)
01754         {
01755             glBindTexture(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p27">m_uiTextureId</a>);
01756             glCopyTexSubImage2D(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>,
01757                                 0, 0, 0, 0, 0, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a>);
01758         }
01759         <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a>)
01760         {
01761             glBindTexture(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p28">m_uiDepthTextureId</a>);
01762             <span class="comment">// HOW TO COPY DEPTH TEXTURE??? Supposedly this just magically works...</span>
01763             <span class="comment">// [Redge]</span>
01764             <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p4">m_bHasARBDepthTexture</a>)
01765             {
01766                 glCopyTexSubImage2D(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, 0, 0, 0, 0, 0,
01767                                     <a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a>);
01768             }
01769             <span class="keywordflow">else</span>
01770             {
01771                 <span class="comment">// no 'real' depth texture available, so behavior has to be emulated</span>
01772                 <span class="comment">// using glReadPixels (beware, this is (naturally) slow ...)</span>
01773                 glReadPixels(0, 0, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a>, GL_DEPTH_COMPONENT,
01774                              GL_UNSIGNED_SHORT, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p29">m_ausPoorDepthTexture</a>);
01775                 glTexImage2D(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, 0, GL_LUMINANCE16,
01776                              <a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a>, 0, GL_LUMINANCE,
01777                              GL_UNSIGNED_SHORT, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p29">m_ausPoorDepthTexture</a>);
01778             }
01779             <span class="comment">// [/Redge]</span>
01780         }
01781     }
01782 
01783 <span class="preprocessor">#else</span>
01784 <span class="preprocessor"></span>    assert(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a>);
01785     glBindTexture(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, m_iTextureId);
01786     glCopyTexSubImage2D(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, 0, 0, 0, 0, 0, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p0">m_iWidth</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p1">m_iHeight</a>);
01787 <span class="preprocessor">#endif</span>
01788 <span class="preprocessor"></span>
01789 }
01790 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l01791"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#b7">01791</a> <span class="keywordtype">bool</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#b7">SpStreamBuffer::releaseBoundBuffers</a>()
01792 {
01793     <span class="comment">// Releases buffer bindings on RenderTextures with RT_RENDER_TO_TEXTURE</span>
01794 
01795 <span class="preprocessor">#ifdef _WIN32</span>
01796 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p2">m_bIsTexture</a> &amp;&amp; RT_RENDER_TO_TEXTURE == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a>)
01797     {
01798         glBindTexture(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p27">m_uiTextureId</a>);
01799 
01800         <span class="comment">// release the pbuffer from the render texture object</span>
01801         <span class="keywordflow">if</span> (0 != <a class="code" href="classSpark_1_1SpStreamBuffer.html#p9">m_iCurrentBoundBuffer</a> &amp;&amp; <a class="code" href="classSpark_1_1SpStreamBuffer.html#p8">m_bIsBufferBound</a>)
01802         {
01803             <span class="keywordflow">if</span> (FALSE == wglReleaseTexImageARB(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p9">m_iCurrentBoundBuffer</a>))
01804             {
01805                 wglGetLastError();
01806                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
01807             }
01808             <a class="code" href="classSpark_1_1SpStreamBuffer.html#p8">m_bIsBufferBound</a> = <span class="keyword">false</span>;
01809         }
01810     }
01811 
01812     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#p3">m_bIsDepthTexture</a> &amp;&amp; RT_RENDER_TO_TEXTURE == <a class="code" href="classSpark_1_1SpStreamBuffer.html#p5">m_eUpdateMode</a>)
01813     {
01814         glBindTexture(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p26">m_eTextureTarget</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p28">m_uiDepthTextureId</a>);
01815 
01816         <span class="comment">// release the pbuffer from the render texture object</span>
01817         <span class="keywordflow">if</span> (FALSE == wglReleaseTexImageARB(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>, WGL_DEPTH_COMPONENT_NV))
01818         {
01819             wglGetLastError();
01820             <span class="keywordflow">return</span> <span class="keyword">false</span>;
01821         }
01822     }
01823 
01824 <span class="preprocessor">#else</span>
01825 <span class="preprocessor"></span>    <span class="comment">// textures can't be bound in Linux</span>
01826 <span class="preprocessor">#endif</span>
01827 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;
01828 }
01829 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l01830"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#b8">01830</a> <span class="keywordtype">bool</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#b8">SpStreamBuffer::makeCurrent</a>()
01831 {
01832 <span class="preprocessor">#ifdef _WIN32</span>
01833 <span class="preprocessor"></span>    <span class="comment">// make the pbuffer's rendering context current.</span>
01834     <span class="keywordflow">if</span> (FALSE == wglMakeCurrent( m_hDC, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a>))
01835     {
01836         wglGetLastError();
01837         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01838     }
01839 <span class="preprocessor">#else</span>
01840 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<span class="keyword">false</span> == glXMakeCurrent(<a class="code" href="classSpark_1_1SpStreamBuffer.html#p21">m_pkDisplay</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p23">m_hPixelBuffer</a>, <a class="code" href="classSpark_1_1SpStreamBuffer.html#p22">m_hGLContext</a>))
01841     {
01842         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01843     }
01844 <span class="preprocessor">#endif</span>
01845 <span class="preprocessor"></span>
01846     <span class="keywordflow">return</span> <span class="keyword">true</span>;
01847 }
01848 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l01849"></a><a class="code" href="classSpark_1_1SpStreamBuffer.html#a12">01849</a> <span class="keywordtype">void</span> <a class="code" href="classSpark_1_1SpStreamBuffer.html#a12">SpStreamBuffer::enableTextureFiltering</a>()
01850 {
01851     <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#a38">isMipMapped</a>())
01852     {
01853         <span class="comment">// Enable trilinear filtering so we can see the mipmapping</span>
01854         <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#a31">isTexture</a>())
01855         {
01856             <a class="code" href="classSpark_1_1SpStreamBuffer.html#a9">bind</a>();
01857             glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#a17">getTextureTarget</a>(),
01858                             GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
01859             glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#a17">getTextureTarget</a>(),
01860                             GL_TEXTURE_MAG_FILTER, GL_LINEAR);
01861             glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#a17">getTextureTarget</a>(),
01862                             GL_GENERATE_MIPMAP_SGIS, GL_TRUE);
01863         }
01864 
01865         <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#a32">isDepthTexture</a>())
01866         {
01867             <a class="code" href="classSpark_1_1SpStreamBuffer.html#a10">bindDepth</a>();
01868             glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#a17">getTextureTarget</a>(),
01869                             GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
01870             glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#a17">getTextureTarget</a>(),
01871                             GL_TEXTURE_MAG_FILTER, GL_LINEAR);
01872             glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#a17">getTextureTarget</a>(),
01873                             GL_GENERATE_MIPMAP_SGIS, GL_TRUE);
01874         }
01875     }
01876     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(<a class="code" href="classSpark_1_1SpStreamBuffer.html#a35">isRectangleTexture</a>() || <a class="code" href="classSpark_1_1SpStreamBuffer.html#a33">isFloatTexture</a>()))
01877     {
01878         <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#a31">isTexture</a>())
01879         {
01880             <a class="code" href="classSpark_1_1SpStreamBuffer.html#a9">bind</a>();
01881             glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#a17">getTextureTarget</a>(),
01882                             GL_TEXTURE_MIN_FILTER, GL_LINEAR);
01883             glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#a17">getTextureTarget</a>(),
01884                             GL_TEXTURE_MAG_FILTER, GL_LINEAR);
01885         }
01886 
01887         <span class="keywordflow">if</span> (<a class="code" href="classSpark_1_1SpStreamBuffer.html#a32">isDepthTexture</a>())
01888         {
01889             <a class="code" href="classSpark_1_1SpStreamBuffer.html#a10">bindDepth</a>();
01890             glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#a17">getTextureTarget</a>(),
01891                             GL_TEXTURE_MIN_FILTER, GL_LINEAR);
01892             glTexParameteri(<a class="code" href="classSpark_1_1SpStreamBuffer.html#a17">getTextureTarget</a>(),
01893                             GL_TEXTURE_MAG_FILTER, GL_LINEAR);
01894         }
01895     }
01896 }
01897 <span class="comment">// ---------------------------------------------------------------------------</span>
</div></pre>		<div class="footer" width="100%">
		<hr>
			<a href="http://lyon-smith.org/">&copy; Derek Gerstmann - NCCA - Bournemouth University - 2004</a>
		</div>
		<br>
	</body>
</html>
