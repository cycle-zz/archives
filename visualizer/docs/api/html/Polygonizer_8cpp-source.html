<html>
	<head>
		<title>Branch - API Documentation</title>
		<link HREF="style.css" REL="stylesheet" TYPE="text/css">
	</head>
	<body>
		<div width="100%" height="40px" class="banner">
			Visualizer - API Documentation
		</div>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>Polygonizer.cpp</h1><a href="Polygonizer_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="preprocessor">#include "<a class="code" href="DataTypes_8h.html">DataTypes.h</a>"</span>
00002 <span class="preprocessor">#include "<a class="code" href="Polygonizer_8h.html">Polygonizer.h</a>"</span>
00003 <span class="preprocessor">#include "<a class="code" href="Shading_8h.html">Shading.h</a>"</span>
00004 
00005 <span class="keyword">using</span> <span class="keyword">namespace </span>dg;
00006 
00007 <span class="comment">//******************************************************************************</span>
<a name="l00008"></a><a class="code" href="classdg_1_1Polygonizer.html#a0">00008</a> Polygonizer::Polygonizer(
00009         Function pvFunction, <a class="code" href="namespacedg.html#a14">Int</a> iCellCount, <a class="code" href="namespacedg.html#a28">Real</a> fScale, <a class="code" href="namespacedg.html#a28">Real</a> fIsoLevel)
00010         : m_kVertexList(1, 1000), m_kNormalList(1, 1000), m_kColorList(1, 1000)  
00011 {
00012         <a class="code" href="classdg_1_1Polygonizer.html#n0">m_pvFunction</a> = pvFunction;
00013         <a class="code" href="classdg_1_1Polygonizer.html#n2">m_iCellCount</a> = iCellCount;
00014         <a class="code" href="classdg_1_1Polygonizer.html#n3">m_fScale</a> = fScale;
00015         <a class="code" href="classdg_1_1Polygonizer.html#n4">m_fDelta</a> = 1.0 / <a class="code" href="classdg_1_1Polygonizer.html#n2">m_iCellCount</a>;
00016         <a class="code" href="classdg_1_1Polygonizer.html#n5">m_fEpsilon</a> = 0.01;
00017         <a class="code" href="classdg_1_1Polygonizer.html#n6">m_fIsoLevel</a> = fIsoLevel;        
00018 }
00019 <span class="comment">//******************************************************************************</span>
<a name="l00020"></a><a class="code" href="classdg_1_1Polygonizer.html#a20">00020</a> <span class="keywordtype">void</span> Polygonizer::getNormal(<a class="code" href="classdg_1_1Vector.html">Vector</a> &amp;rkNormal, <a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ)
00021 {
00022         rkNormal.<a class="code" href="classdg_1_1Vector.html#a2">x</a>() = <a class="code" href="classdg_1_1Polygonizer.html#a1">sample</a>(fX - <a class="code" href="classdg_1_1Polygonizer.html#n5">m_fEpsilon</a>, fY, fZ) - 
00023                                    <a class="code" href="classdg_1_1Polygonizer.html#a1">sample</a>(fX + <a class="code" href="classdg_1_1Polygonizer.html#n5">m_fEpsilon</a>, fY, fZ);
00024         
00025         rkNormal.<a class="code" href="classdg_1_1Vector.html#a3">y</a>() = <a class="code" href="classdg_1_1Polygonizer.html#a1">sample</a>(fX, fY - <a class="code" href="classdg_1_1Polygonizer.html#n5">m_fEpsilon</a>, fZ) - 
00026                                    <a class="code" href="classdg_1_1Polygonizer.html#a1">sample</a>(fX, fY + <a class="code" href="classdg_1_1Polygonizer.html#n5">m_fEpsilon</a>, fZ);
00027 
00028         rkNormal.<a class="code" href="classdg_1_1Vector.html#a4">z</a>() = <a class="code" href="classdg_1_1Polygonizer.html#a1">sample</a>(fX, fY, fZ - <a class="code" href="classdg_1_1Polygonizer.html#n5">m_fEpsilon</a>) - 
00029                                    <a class="code" href="classdg_1_1Polygonizer.html#a1">sample</a>(fX, fY, fZ + <a class="code" href="classdg_1_1Polygonizer.html#n5">m_fEpsilon</a>);
00030 
00031         rkNormal.<a class="code" href="classdg_1_1Vector.html#a34">normalize</a>();
00032 }
00033 <span class="comment">//******************************************************************************</span>
<a name="l00034"></a><a class="code" href="classdg_1_1Polygonizer.html#a21">00034</a> <span class="keywordtype">void</span> Polygonizer::marchCube(<a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ, <a class="code" href="namespacedg.html#a28">Real</a> fScale)
00035 {
00036         <span class="keywordflow">if</span>(!<a class="code" href="classdg_1_1Polygonizer.html#n0">m_pvFunction</a>)
00037                 <span class="keywordflow">return</span>;
00038         
00039         <a class="code" href="namespacedg.html#a28">Real</a> afCubeValue[8];            <span class="comment">// sampled values for each cube corner</span>
00040         <a class="code" href="classdg_1_1Vector.html">Vector</a> akEdgeVector[12];        <span class="comment">// edge vertices</span>
00041         <a class="code" href="classdg_1_1Vector.html">Vector</a> akEdgeNorm[12];          <span class="comment">// edge normals</span>
00042 
00043         <span class="comment">// get values for each cube corner</span>
00044         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iV = 0; iV &lt; 8; iV++)
00045         {
00046                 afCubeValue[iV] = <a class="code" href="classdg_1_1Polygonizer.html#a1">sample</a>(fX + ms_aafCubeOffsets[iV][0] * fScale,
00047                                          fY + ms_aafCubeOffsets[iV][1] * fScale,
00048                                          fZ + ms_aafCubeOffsets[iV][2] * fScale);
00049         }
00050 
00051         <span class="comment">// determine inside and outside points</span>
00052         <span class="keywordtype">int</span> iFlagIndex = 0;
00053         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iTest = 0; iTest &lt; 8; iTest++)
00054         {
00055                 <span class="keywordflow">if</span> (afCubeValue[iTest] &lt;= <a class="code" href="classdg_1_1Polygonizer.html#n6">m_fIsoLevel</a>)
00056                         iFlagIndex |= 1 &lt;&lt; iTest;
00057         }
00058 
00059         <span class="comment">// get edge bits to determine surface intersection</span>
00060         <span class="keywordtype">int</span> iEdgeBits = ms_aiCubeEdgeBits[iFlagIndex];
00061 
00062         <span class="comment">// return if cube does not intersect with surface</span>
00063         <span class="keywordflow">if</span> (iEdgeBits == 0)
00064                 <span class="keywordflow">return</span> ;
00065 
00066         <span class="comment">// determine intersection point for each edge</span>
00067         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iE = 0; iE &lt; 12; iE++)
00068         {
00069                 <span class="comment">// get the intersection point if there is one</span>
00070                 <span class="keywordflow">if</span> (iEdgeBits &amp; (1 &lt;&lt; iE))
00071                 {
00072                         <span class="comment">// get the intersection offset</span>
00073                         <a class="code" href="namespacedg.html#a28">Real</a> fOffset = <a class="code" href="classdg_1_1Polygonizer.html#a18">getIntersect</a>(afCubeValue[ ms_aaiCubeConnects[iE][0] ],
00074                                                     afCubeValue[ ms_aaiCubeConnects[iE][1] ],
00075                                                                                 <a class="code" href="classdg_1_1Polygonizer.html#n6">m_fIsoLevel</a>);
00076                         <span class="comment">// create the edge</span>
00077                         akEdgeVector[iE].<a class="code" href="classdg_1_1Vector.html#a2">x</a>() = fX + (ms_aafCubeOffsets[ ms_aaiCubeConnects[iE][0] ][0] + 
00078                                                                  fOffset * ms_aafCubeDirs[iE][0]) * fScale;
00079                                                                  
00080                         akEdgeVector[iE].<a class="code" href="classdg_1_1Vector.html#a3">y</a>() = fY + (ms_aafCubeOffsets[ ms_aaiCubeConnects[iE][0] ][1] + 
00081                                                                  fOffset * ms_aafCubeDirs[iE][1]) * fScale;
00082                                                                  
00083                         akEdgeVector[iE].<a class="code" href="classdg_1_1Vector.html#a4">z</a>() = fZ + (ms_aafCubeOffsets[ ms_aaiCubeConnects[iE][0] ][2] + 
00084                                                                  fOffset * ms_aafCubeDirs[iE][2]) * fScale;
00085 
00086                         <span class="comment">// get the normal for this edge</span>
00087                         <a class="code" href="classdg_1_1Polygonizer.html#a20">getNormal</a>(akEdgeNorm[iE], 
00088                                           akEdgeVector[iE].x(), 
00089                                           akEdgeVector[iE].y(), 
00090                                           akEdgeVector[iE].z());
00091                 }
00092         }
00093 
00094         <span class="comment">// create the triangles (max 5) for the intersections</span>
00095         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iTri = 0; iTri &lt; 5; iTri++)
00096         {
00097                 <span class="keywordflow">if</span> (ms_aaiTriConnects[iFlagIndex][3*iTri] &lt; 0)
00098                         <span class="keywordflow">break</span>;
00099 
00100                 <span class="comment">// for each triangle corner</span>
00101                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iC = 0; iC &lt; 3; iC++)
00102                 {
00103                         <span class="comment">// get the vertex index</span>
00104                         <span class="keywordtype">int</span> iV = ms_aaiTriConnects[iFlagIndex][3 * iTri + iC];
00105 
00106                         <span class="comment">// get a color value for this triangle</span>
00107                         <a class="code" href="classdg_1_1Color.html">Color</a> kColor;   
00108                         <a class="code" href="classdg_1_1Polygonizer.html#a19">getColor</a>(kColor, akEdgeVector[iV], akEdgeNorm[iV]);
00109                         
00110                         <span class="comment">// add the colors, normals and vertices</span>
00111                         <a class="code" href="classdg_1_1Polygonizer.html#n10">m_kColorList</a>.insert( kColor );
00112                         <a class="code" href="classdg_1_1Polygonizer.html#n9">m_kNormalList</a>.insert( akEdgeNorm[iV] );
00113                         <a class="code" href="classdg_1_1Polygonizer.html#n8">m_kVertexList</a>.insert( akEdgeVector[iV] );
00114                 }
00115         }
00116 }
00117 <span class="comment">//******************************************************************************</span>
<a name="l00118"></a><a class="code" href="classdg_1_1Polygonizer.html#a22">00118</a> <span class="keywordtype">void</span> Polygonizer::marchTetra(<a class="code" href="classdg_1_1Vector.html">Vector</a> *pakTetraPos, <a class="code" href="namespacedg.html#a28">Real</a> *pafTetraValue)
00119 {
00120         <span class="keywordflow">if</span>(!<a class="code" href="classdg_1_1Polygonizer.html#n0">m_pvFunction</a>)
00121                 <span class="keywordflow">return</span>;
00122         
00123         <a class="code" href="classdg_1_1Vector.html">Vector</a> akEdgeVector[6];         <span class="comment">// edge vertices</span>
00124         <a class="code" href="classdg_1_1Vector.html">Vector</a> akEdgeNorm[6];           <span class="comment">// edge normals</span>
00125 
00126         <span class="comment">// determine inside and outside points</span>
00127         <span class="keywordtype">int</span> iFlagIndex = 0;
00128         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iV = 0; iV &lt; 4; iV++)
00129         {
00130                 <span class="keywordflow">if</span> (pafTetraValue[iV] &lt;= <a class="code" href="classdg_1_1Polygonizer.html#n6">m_fIsoLevel</a>)
00131                         iFlagIndex |= 1 &lt;&lt; iV;
00132         }
00133 
00134         <span class="comment">// get edge bits to determine surface intersection</span>
00135         <span class="keywordtype">int</span> iEdgeBits = ms_aiTetraEdgeBits[iFlagIndex];
00136 
00137         <span class="comment">// return if tetra does not intersect with surface</span>
00138         <span class="keywordflow">if</span> (iEdgeBits == 0)
00139                 <span class="keywordflow">return</span> ;
00140 
00141         <span class="comment">// determine intersection point for each edge</span>
00142         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iE = 0; iE &lt; 6; iE++)
00143         {
00144                 <span class="comment">// get the intersection point if there is one</span>
00145                 <span class="keywordflow">if</span>(iEdgeBits &amp; (1 &lt;&lt; iE))
00146                 {
00147                         <span class="comment">// get the tetra vertex indices</span>
00148                         <span class="keywordtype">int</span> iV0 = ms_aaiTetraConnects[iE][0];
00149                         <span class="keywordtype">int</span> iV1 = ms_aaiTetraConnects[iE][1];
00150 
00151                         <span class="comment">// get the intersection point</span>
00152                         <a class="code" href="namespacedg.html#a28">Real</a> fOffset = <a class="code" href="classdg_1_1Polygonizer.html#a18">getIntersect</a>(pafTetraValue[iV0], 
00153                                                                                 pafTetraValue[iV1], 
00154                                                                                 <a class="code" href="classdg_1_1Polygonizer.html#n6">m_fIsoLevel</a>);
00155                                                                                 
00156                         <span class="comment">// precompute the inverse of the intersection offset</span>
00157                         <a class="code" href="namespacedg.html#a28">Real</a> fInvOffset = 1.0 - fOffset;
00158 
00159                         <span class="comment">// create the edge</span>
00160                         akEdgeVector[iE].<a class="code" href="classdg_1_1Vector.html#a2">x</a>() = fInvOffset * pakTetraPos[iV0].<a class="code" href="classdg_1_1Vector.html#a2">x</a>() + 
00161                                                                  fOffset * pakTetraPos[iV1].<a class="code" href="classdg_1_1Vector.html#a2">x</a>();
00162                                                                  
00163                         akEdgeVector[iE].<a class="code" href="classdg_1_1Vector.html#a3">y</a>() = fInvOffset * pakTetraPos[iV0].<a class="code" href="classdg_1_1Vector.html#a3">y</a>() + 
00164                                                                  fOffset * pakTetraPos[iV1].<a class="code" href="classdg_1_1Vector.html#a3">y</a>();
00165                                                                  
00166                         akEdgeVector[iE].<a class="code" href="classdg_1_1Vector.html#a4">z</a>() = fInvOffset * pakTetraPos[iV0].<a class="code" href="classdg_1_1Vector.html#a4">z</a>() + 
00167                                                                  fOffset * pakTetraPos[iV1].<a class="code" href="classdg_1_1Vector.html#a4">z</a>();
00168 
00169                         <span class="comment">// get a normal for this edge</span>
00170                         <a class="code" href="classdg_1_1Polygonizer.html#a20">getNormal</a>(akEdgeNorm[iE], 
00171                                           akEdgeVector[iE].x(), 
00172                                           akEdgeVector[iE].y(), 
00173                                           akEdgeVector[iE].z());
00174                 }
00175         }
00176         
00177         <span class="comment">// create the triangles (max 2) for the intersections</span>
00178         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iTri = 0; iTri &lt; 2; iTri++)
00179         {
00180                 <span class="comment">// return if not a valid triangle</span>
00181                 <span class="keywordflow">if</span> (ms_aaiTetraTris[iFlagIndex][3*iTri] &lt; 0)
00182                         <span class="keywordflow">break</span>;
00183 
00184                 <span class="comment">// for each triangle corner</span>
00185                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iC = 0; iC &lt; 3; iC++)
00186                 {
00187                         <span class="comment">// get the vertex index</span>
00188                         <span class="keywordtype">int</span> iV = ms_aaiTetraTris[iFlagIndex][3 * iTri + iC];
00189 
00190                         <span class="comment">// get a color value for this triangle</span>
00191                         <a class="code" href="classdg_1_1Color.html">Color</a> kColor;                           
00192                         <a class="code" href="classdg_1_1Polygonizer.html#a19">getColor</a>(kColor, akEdgeVector[iV], akEdgeNorm[iV]);
00193                         
00194                         <span class="comment">// add the colors, normals, and vertices</span>
00195                         <a class="code" href="classdg_1_1Polygonizer.html#n10">m_kColorList</a>.insert( kColor );
00196                         <a class="code" href="classdg_1_1Polygonizer.html#n9">m_kNormalList</a>.insert( akEdgeNorm[iV] );
00197                         <a class="code" href="classdg_1_1Polygonizer.html#n8">m_kVertexList</a>.insert( akEdgeVector[iV] );
00198                 }
00199         }
00200 }
00201 <span class="comment">//******************************************************************************</span>
<a name="l00202"></a><a class="code" href="classdg_1_1Polygonizer.html#a23">00202</a> <span class="keywordtype">void</span> Polygonizer::marchTetraCube(<a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ, <a class="code" href="namespacedg.html#a28">Real</a> fScale)
00203 {
00204         <span class="keywordflow">if</span>(!<a class="code" href="classdg_1_1Polygonizer.html#n0">m_pvFunction</a>)
00205                 <span class="keywordflow">return</span>;
00206         
00207         <a class="code" href="classdg_1_1Vector.html">Vector</a> akCubePos[8];    <span class="comment">// positions in cube</span>
00208         <a class="code" href="namespacedg.html#a28">Real</a> afCubeValue[8];    <span class="comment">// values in cube</span>
00209 
00210         <a class="code" href="classdg_1_1Vector.html">Vector</a> akTetraPos[4];   <span class="comment">// positions in tetra</span>
00211         <a class="code" href="namespacedg.html#a28">Real</a> afTetraValue[4];   <span class="comment">// values in tetra</span>
00212 
00213         <span class="comment">// get values for each cube corner</span>
00214         <span class="keywordtype">int</span> iV = 0;
00215         <span class="keywordflow">for</span>(iV = 0; iV &lt; 8; iV++)
00216         {
00217                 akCubePos[iV].<a class="code" href="classdg_1_1Vector.html#a2">x</a>() = fX + ms_aafCubeOffsets[iV][0] * fScale;
00218                 akCubePos[iV].<a class="code" href="classdg_1_1Vector.html#a3">y</a>() = fY + ms_aafCubeOffsets[iV][1] * fScale;
00219                 akCubePos[iV].<a class="code" href="classdg_1_1Vector.html#a4">z</a>() = fZ + ms_aafCubeOffsets[iV][2] * fScale;
00220         }
00221 
00222         <span class="comment">// sample the values for each cube corner</span>
00223         <span class="keywordflow">for</span>(iV = 0; iV &lt; 8; iV++)
00224                 afCubeValue[iV] = <a class="code" href="classdg_1_1Polygonizer.html#a1">sample</a>(akCubePos[iV].x(),
00225                                          akCubePos[iV].y(),
00226                                          akCubePos[iV].z());
00227 
00228         <span class="comment">// for each tetrahedron in the cube</span>
00229         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iT = 0; iT &lt; 6; iT++)
00230         {
00231                 <span class="comment">// for each vertex in the tetrahedron</span>
00232                 <span class="keywordflow">for</span> (iV = 0; iV &lt; 4; iV++)
00233                 {
00234                         <span class="comment">// get the tetra index</span>
00235                         <span class="keywordtype">int</span> iTC = ms_aaiCubeTetras[iT][iV];
00236 
00237                         <span class="comment">// get the vertex positions</span>
00238                         akTetraPos[iV].<a class="code" href="classdg_1_1Vector.html#a2">x</a>() = akCubePos[iTC].<a class="code" href="classdg_1_1Vector.html#a2">x</a>();
00239                         akTetraPos[iV].<a class="code" href="classdg_1_1Vector.html#a3">y</a>() = akCubePos[iTC].<a class="code" href="classdg_1_1Vector.html#a3">y</a>();
00240                         akTetraPos[iV].<a class="code" href="classdg_1_1Vector.html#a4">z</a>() = akCubePos[iTC].<a class="code" href="classdg_1_1Vector.html#a4">z</a>();
00241 
00242                         <span class="comment">// copy the cube value</span>
00243                         afTetraValue[iV] = afCubeValue[iTC];
00244                 }
00245                 
00246                 <span class="comment">// perform the tetra march</span>
00247                 <a class="code" href="classdg_1_1Polygonizer.html#a22">marchTetra</a>(akTetraPos, afTetraValue);
00248         }
00249 }
00250 <span class="comment">//******************************************************************************</span>
<a name="l00251"></a><a class="code" href="classdg_1_1Polygonizer.html#a24">00251</a> <span class="keywordtype">void</span> Polygonizer::evaluate(MarchMethod eType)
00252 {
00253         <span class="keywordflow">if</span>(!<a class="code" href="classdg_1_1Polygonizer.html#n0">m_pvFunction</a>)
00254                 <span class="keywordflow">return</span>;
00255         
00256         <a class="code" href="namespacedg.html#a14">Int</a> iX = 0, iY = 0, iZ = 0;
00257         
00258         <span class="comment">// clear out the geometry list</span>
00259         <a class="code" href="classdg_1_1Polygonizer.html#n8">m_kVertexList</a>.clear();
00260         <a class="code" href="classdg_1_1Polygonizer.html#n9">m_kNormalList</a>.clear();
00261         <a class="code" href="classdg_1_1Polygonizer.html#n10">m_kColorList</a>.clear();
00262                 
00263         <span class="comment">// perform appropriate march type</span>
00264         <span class="comment">// switch done outside the loop to avoid checking at every cell</span>
00265         <span class="keywordflow">if</span> (eType == Polygonizer::MM_CUBES)
00266         {
00267                 <span class="keywordflow">for</span> (iX = 0; iX &lt; <a class="code" href="classdg_1_1Polygonizer.html#n2">m_iCellCount</a>; iX++)
00268                 {
00269                         <span class="keywordflow">for</span> (iY = 0; iY &lt; <a class="code" href="classdg_1_1Polygonizer.html#n2">m_iCellCount</a>; iY++)
00270                         {
00271                                 <span class="keywordflow">for</span> (iZ = 0; iZ &lt; <a class="code" href="classdg_1_1Polygonizer.html#n2">m_iCellCount</a>; iZ++)
00272                                 {
00273                                         <a class="code" href="classdg_1_1Polygonizer.html#a21">marchCube</a>( iX * <a class="code" href="classdg_1_1Polygonizer.html#n4">m_fDelta</a>, 
00274                                                            iY * <a class="code" href="classdg_1_1Polygonizer.html#n4">m_fDelta</a>, 
00275                                                            iZ * <a class="code" href="classdg_1_1Polygonizer.html#n4">m_fDelta</a>, 
00276                                                            <a class="code" href="classdg_1_1Polygonizer.html#n4">m_fDelta</a>);
00277                                 }
00278                         }
00279                 }
00280         }
00281         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(eType == Polygonizer::MM_TETRA)
00282         {
00283                 <span class="keywordflow">for</span> (iX = 0; iX &lt; <a class="code" href="classdg_1_1Polygonizer.html#n2">m_iCellCount</a>; iX++)
00284                 {
00285                         <span class="keywordflow">for</span> (iY = 0; iY &lt; <a class="code" href="classdg_1_1Polygonizer.html#n2">m_iCellCount</a>; iY++)
00286                         {
00287                                 <span class="keywordflow">for</span> (iZ = 0; iZ &lt; <a class="code" href="classdg_1_1Polygonizer.html#n2">m_iCellCount</a>; iZ++)
00288                                 {
00289                                         <a class="code" href="classdg_1_1Polygonizer.html#a23">marchTetraCube</a>( iX * <a class="code" href="classdg_1_1Polygonizer.html#n4">m_fDelta</a>, 
00290                                                                         iY * <a class="code" href="classdg_1_1Polygonizer.html#n4">m_fDelta</a>, 
00291                                                                         iZ * <a class="code" href="classdg_1_1Polygonizer.html#n4">m_fDelta</a>, 
00292                                                                         <a class="code" href="classdg_1_1Polygonizer.html#n4">m_fDelta</a>);
00293                                 }
00294                         }
00295                 }
00296         }
00297 }
00298 <span class="comment">//******************************************************************************</span>
</pre></div>		<div class="footer" width="100%">
		<hr>
			<a href="http://lyon-smith.org/">&copy; Derek Gerstmann - NCCA - Bournemouth University - 2004</a>
		</div>
		<br>
	</body>
</html>
