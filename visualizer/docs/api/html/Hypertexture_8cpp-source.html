<html>
	<head>
		<title>Branch - API Documentation</title>
		<link HREF="style.css" REL="stylesheet" TYPE="text/css">
	</head>
	<body>
		<div width="100%" height="40px" class="banner">
			Visualizer - API Documentation
		</div>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>Hypertexture.cpp</h1><a href="Hypertexture_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="preprocessor">#include "<a class="code" href="Hypertexture_8h.html">Hypertexture.h</a>"</span>
00002 <span class="preprocessor">#include "<a class="code" href="Operators_8h.html">Operators.h</a>"</span>
00003 <span class="preprocessor">#include "<a class="code" href="Random_8h.html">Random.h</a>"</span>
00004 <span class="preprocessor">#include "<a class="code" href="Camera_8h.html">Camera.h</a>"</span>
00005 <span class="preprocessor">#include "<a class="code" href="Image_8h.html">Image.h</a>"</span>
00006 <span class="preprocessor">#include "<a class="code" href="Maths_8h.html">Maths.h</a>"</span>
00007 <span class="preprocessor">#include "<a class="code" href="Shading_8h.html">Shading.h</a>"</span>
00008 <span class="preprocessor">#include &lt;memory&gt;</span>
00009 
00010 <span class="keyword">using</span> <span class="keyword">namespace </span>dg;
00011 
00012 <span class="comment">//******************************************************************************</span>
00013 Hypertexture::Hypertexture(
00014         DensityFn pvDensityFn,
00015         ColorFn pvColorFn,
00016         ShadeFn pvShadeFn,
00017         Camera* pkCamera)
00018                 : m_kLightColor(5.0f, 5.0f, 5.0f),
00019                 m_kShadowColor(0.0f, 0.0f, 0.25f)
00020 {
00021         m_fRayEpsilon = 1.0e-4;
00022         m_fDensityThreshold = 0.5;
00023         m_fDensityScale = 35;
00024         m_fStepScale = 3.0;
00025         m_fShadowStepScale = 2.0;
00026         m_fShadowFarClip = 1.0;
00027         m_fShadowDepthThreshold = 2.3;
00028         m_fIlluminationScale = 0.5;
00029         m_fOpacityThreshold = 0.9999;
00030 
00031         m_fAmbient = 0.127;
00032         m_fDiffuse = 1;
00033         m_fSpecular = 0.3;
00034         m_fRoughness = 0.1;
00035 
00036         m_fOpacityDensity = 1;
00037         m_fLightDensity = 1;
00038         m_fShadowDensity = 1;
00039 
00040         m_fScale = 1.0;
00041         m_fStepSize = 0.1;
00042         m_fShadowStepSize = 0.5;
00043         m_fNoiseFreq = 2.0;
00044         m_fThreshold = 0.5;
00045 
00046         m_uiRayHits = 0;
00047         m_uiSamples = 0;
00048         m_uiMaxSamples = 0;
00049 
00050         m_bJitter = <span class="keyword">true</span>;
00051         m_bKeepInView = <span class="keyword">true</span>;
00052         m_bFadeOut = <span class="keyword">false</span>;
00053 
00054         m_pvDensityFn = pvDensityFn;
00055         m_pvColorFn = pvColorFn;
00056         m_pvShadeFn = pvShadeFn;
00057         m_pkCamera = pkCamera;
00058 
00059         m_pvFilteredColorFn = NULL;
00060         m_pvFilteredDensityFn = NULL;
00061 }
00062 <span class="comment">//******************************************************************************</span>
<a name="l00063"></a><a class="code" href="classdg_1_1Hypertexture.html#a1">00063</a> Hypertexture::~Hypertexture()
00064 {
00065         <span class="comment">// EMPTY!</span>
00066 }
00067 <span class="comment">//******************************************************************************</span>
<a name="l00068"></a><a class="code" href="classdg_1_1Hypertexture.html#a49">00068</a> <span class="keywordtype">void</span> Hypertexture::render()
00069 {
00070         <span class="keywordflow">if</span>(!m_pkCamera)
00071                 <span class="keywordflow">return</span>;
00072 
00073         <span class="comment">// get the image from the camera</span>
00074         <a class="code" href="classdg_1_1Image.html">Image</a>* pkImage = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a28">getImage</a>();
00075         <span class="keywordflow">if</span>(!pkImage)
00076                 <span class="keywordflow">return</span>;
00077 
00078         <a class="code" href="classdg_1_1Hypertexture.html#a49">render</a>(0, pkImage-&gt;<a class="code" href="classdg_1_1Image.html#a9">height</a>());
00079 
00080 <span class="comment">//    if ( m_bBlur )</span>
00081 <span class="comment">//        pkImage-&gt;blur();</span>
00082 }
00083 <span class="comment">//******************************************************************************</span>
<a name="l00084"></a><a class="code" href="classdg_1_1Hypertexture.html#a50">00084</a> <span class="keywordtype">void</span> Hypertexture::render(<a class="code" href="namespacedg.html#a15">UInt</a> uiStartLine, <a class="code" href="namespacedg.html#a15">UInt</a> uiEndLine)
00085 {
00086         <span class="keywordflow">if</span>(!m_pkCamera)
00087                 <span class="keywordflow">return</span>;
00088 
00089         <span class="comment">// get the image from the camera</span>
00090         <a class="code" href="classdg_1_1Image.html">Image</a>* pkImage = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a28">getImage</a>();
00091         <span class="keywordflow">if</span>(!pkImage)
00092                 <span class="keywordflow">return</span>;
00093 
00094         <span class="comment">// get the image size</span>
00095         <a class="code" href="namespacedg.html#a15">UInt</a> uiWidth = pkImage-&gt;<a class="code" href="classdg_1_1Image.html#a8">width</a>();
00096         <a class="code" href="namespacedg.html#a15">UInt</a> uiHeight = pkImage-&gt;<a class="code" href="classdg_1_1Image.html#a9">height</a>();
00097 
00098         <span class="comment">// get the clipping planes</span>
00099         <a class="code" href="namespacedg.html#a28">Real</a> fNear = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a12">getNear</a>();
00100         <a class="code" href="namespacedg.html#a28">Real</a> fFar = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a14">getFar</a>();
00101         <a class="code" href="namespacedg.html#a28">Real</a> fHW = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a16">getHalfWidth</a>();
00102         <a class="code" href="namespacedg.html#a28">Real</a> fHH = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a20">getHalfHeight</a>();
00103 
00104         <span class="comment">// set the testing radius</span>
00105         <a class="code" href="namespacedg.html#a28">Real</a> fRadius = fFar - fNear;
00106 
00107         <span class="comment">// get the camera frame</span>
00108         <a class="code" href="classdg_1_1Vector.html">Vector</a> kCamDir = <a class="code" href="namespacedg.html#a186">Normalize</a>(m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a5">getDirection</a>());
00109         <a class="code" href="classdg_1_1Vector.html">Vector</a> kCamRight = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a9">getRight</a>();
00110         <a class="code" href="classdg_1_1Vector.html">Vector</a> kCamUp = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a7">getUp</a>();
00111 
00112         <span class="comment">// calculate the increment for ray marching (fixed size)</span>
00113         <a class="code" href="namespacedg.html#a28">Real</a> fMultX = 2.0 / (uiWidth - 1.0f);
00114         <a class="code" href="namespacedg.html#a28">Real</a> fMultY = 2.0 / (uiHeight - 1.0f);
00115         <span class="comment">//Real fIncrement = m_fStepScale * m_pkCamera-&gt;getPixelWidth();</span>
00116         <a class="code" href="namespacedg.html#a28">Real</a> fIncrement = m_fStepSize;
00117 
00118         <span class="comment">// setup for gathering statistics</span>
00119         m_uiRayHits = 0;
00120         m_uiSamples = 0;
00121 
00122         <span class="comment">// render each scanline from top to bottom</span>
00123         <span class="keywordflow">for</span>( <a class="code" href="namespacedg.html#a15">UInt</a> uiY = uiStartLine; uiY &lt; uiEndLine &amp;&amp; uiY &lt; uiHeight; uiY++ )
00124         {
00125                 <span class="comment">// calculate the pixels location</span>
00126                 <a class="code" href="namespacedg.html#a28">Real</a> fY = fHH * (-1.0f + fMultY * uiY);
00127 
00128                 <span class="comment">// render the scanline</span>
00129                 <span class="keywordflow">for</span>( <a class="code" href="namespacedg.html#a15">UInt</a> uiX = 0; uiX &lt; uiWidth; uiX++ )
00130                 {
00131                         <span class="comment">// calculate the pixels location</span>
00132                         <a class="code" href="namespacedg.html#a28">Real</a> fX = fHW * (-1.0f + fMultX * uiX);
00133 
00134                         <span class="comment">// compute ray direction starting from near clip plane</span>
00135                         <a class="code" href="classdg_1_1Vector.html">Vector</a> kRayDir = fNear * kCamDir + fX * kCamRight + fY * kCamUp;
00136 
00137                         <span class="comment">// integrate the volume</span>
00138                         <a class="code" href="classdg_1_1Color.html">Color</a> kColor;
00139                         integrate( kRayDir*fNear, kRayDir, fRadius, fIncrement, kColor );
00140 
00141                         <span class="comment">// update the image</span>
00142                         pkImage-&gt;<a class="code" href="classdg_1_1Image.html#a19">setColor</a>(uiX, uiY, kColor);
00143                 }
00144         }
00145 }
00146 <span class="comment">//******************************************************************************</span>
00147 <span class="keywordtype">void</span> Hypertexture::integrate(
00148         <span class="keyword">const</span> Vector&amp; rkPos, <span class="keyword">const</span> Vector&amp; rkRayDir, <a class="code" href="namespacedg.html#a28">Real</a> fRadius,
00149         <a class="code" href="namespacedg.html#a28">Real</a> fStepSize, Color&amp; rkColor)
00150 {
00151         <span class="comment">// setup for integration</span>
00152         <a class="code" href="namespacedg.html#a28">Real</a> fDensity = 0.0;
00153 
00154         <span class="comment">// setup for accumulation</span>
00155         <a class="code" href="namespacedg.html#a28">Real</a> fAccumOpacity = 0.0;
00156         Color kAccumColor;
00157 
00158         <span class="comment">// check sphere for intersection points to determine start and end</span>
00159         <a class="code" href="namespacedg.html#a28">Real</a> fT0, fT1;
00160         <a class="code" href="namespacedg.html#a28">Real</a> fHits = <a class="code" href="namespacedg.html#a177">RaySphere</a>(rkPos, -rkRayDir, fRadius, m_fRayEpsilon, fT0, fT1);
00161 
00162         <span class="comment">// determine the distance to march</span>
00163         <a class="code" href="namespacedg.html#a28">Real</a> fEnd = (fHits &gt; 0) ? fT0 : 0;
00164         Vector kOrigin = rkPos - fT0 * rkRayDir;
00165 
00166         <span class="comment">// set the current distance to the initial step size</span>
00167         <a class="code" href="namespacedg.html#a28">Real</a> fDistance = fStepSize;
00168 
00169         <span class="comment">// jitter the starting distance to reduce artifacts for large stepsizes</span>
00170         <span class="keywordflow">if</span>(m_bJitter)
00171                 fDistance *= <a class="code" href="namespacedg.html#a168">RandomUnitReal</a>();
00172 
00173         <span class="comment">// calculate a reasonable step size</span>
00174         <a class="code" href="namespacedg.html#a28">Real</a> fStride = <a class="code" href="namespacedg.html#a105">Min</a>(fStepSize, fEnd - fDistance);
00175 
00176         <span class="comment">// integrate forwards from the start vector</span>
00177         Vector kSamplePos = kOrigin + fDistance * rkRayDir;
00178 
00179         <span class="comment">// get the current sample densnity</span>
00180         <a class="code" href="namespacedg.html#a28">Real</a> fPrevDensity = computeDensity(     kSamplePos, fRadius,
00181                                                                                 m_fNoiseFreq, fStepSize);
00182 
00183         <span class="comment">// get the current sample color</span>
00184         Color kPrevColor = computeShading( kSamplePos, rkRayDir, fDensity,
00185                                                                            fRadius, m_fShadowDensity, m_fNoiseFreq,
00186                                                                            m_fShadowStepSize, m_fDensityThreshold);
00187 
00188         <span class="comment">// sharpen at volume boundary</span>
00189         fPrevDensity = <a class="code" href="namespacedg.html#a156">SmoothStep</a>( m_fDensityThreshold,
00190                                                            m_fDensityThreshold + ms_fBoundaryOffset,
00191                                                            fPrevDensity);
00192 
00193         <span class="comment">// continue marching from start to end or total opacity is reached</span>
00194         <span class="keywordflow">while</span> (fDistance &lt;= fEnd &amp;&amp; fAccumOpacity &lt; m_fOpacityThreshold )
00195         {
00196                 <span class="comment">// step along the path, always progressing forward</span>
00197                 fStride = <a class="code" href="namespacedg.html#a62">Clamp</a>(fStride, ms_fMinStride, fEnd - fDistance);
00198                 fDistance += fStride;
00199 
00200                 <span class="comment">// calculate the scattered light and density</span>
00201                 kSamplePos = kOrigin + fDistance * rkRayDir;
00202                 <a class="code" href="namespacedg.html#a28">Real</a> fCurrentDensity = computeDensity( kSamplePos, fRadius,
00203                                                                                          m_fNoiseFreq, fStepSize);
00204 
00205                 <span class="comment">// shade if necessary</span>
00206                 Color kCurrentColor;
00207                 <span class="keywordflow">if</span> (fCurrentDensity &gt; m_fDensityThreshold)
00208                 {
00209                         kCurrentColor = computeShading( kSamplePos, rkRayDir,
00210                                                                         fCurrentDensity, fRadius, m_fShadowDensity,
00211                                                                         m_fNoiseFreq, m_fShadowStepSize,
00212                                                                         m_fDensityThreshold);
00213 
00214                         m_uiRayHits++;
00215                 }
00216 
00217                 <span class="comment">// sharpen at boundary</span>
00218                 fCurrentDensity = <a class="code" href="namespacedg.html#a156">SmoothStep</a>( m_fDensityThreshold,
00219                                                                           m_fDensityThreshold + ms_fBoundaryOffset,
00220                                                                           fCurrentDensity);
00221 
00222                 <span class="comment">// calculate current optical path length</span>
00223                 <a class="code" href="namespacedg.html#a28">Real</a> fTau = m_fOpacityDensity * fStride / 2.0 *
00224                                         (fCurrentDensity + fPrevDensity);
00225 
00226                 <span class="comment">// compute color from current density</span>
00227                 Color kTauColor = m_fLightDensity * fStride / 2.0 *
00228                                                   (kCurrentColor * fCurrentDensity +
00229                                                   kPrevColor * fPrevDensity);
00230 
00231                 <span class="comment">// apply exponentially decay to path length</span>
00232                 <a class="code" href="namespacedg.html#a28">Real</a> fAlpha = 1 - <a class="code" href="namespacedg.html#a93">Exp</a>( -fTau );
00233 
00234                 <span class="comment">// composite with background light</span>
00235                 kAccumColor += (1.0f - fAccumOpacity) * kCurrentColor * fAlpha;
00236                 fAccumOpacity += (1.0f - fAccumOpacity) * fAlpha;
00237 
00238                 <span class="comment">// setup for next iteration</span>
00239                 fPrevDensity = fCurrentDensity;
00240                 kPrevColor = kTauColor;
00241 
00242                 <span class="comment">// update stats counter</span>
00243                 m_uiSamples++;
00244         }
00245 
00246         <span class="comment">// return the accumulated result</span>
00247         rkColor = kAccumColor;
00248         rkColor.a() = fAccumOpacity;
00249         <span class="keywordflow">if</span>(fAccumOpacity == 0)
00250                 rkColor = m_kBgColor;
00251 }
00252 <span class="comment">//******************************************************************************</span>
00253 <a class="code" href="namespacedg.html#a28">Real</a> Hypertexture::computeDensity(
00254         <span class="keyword">const</span> Vector&amp; rkPos, <a class="code" href="namespacedg.html#a28">Real</a> fRadius, <a class="code" href="namespacedg.html#a28">Real</a> fNoiseFreq, <a class="code" href="namespacedg.html#a28">Real</a> fStepSize)
00255 {
00256         <span class="comment">//Real fSamplePosX = m_fScale * (rkPos.x() + m_kOffset.x());</span>
00257         <span class="comment">//Real fSamplePosY = m_fScale * (rkPos.y() + m_kOffset.y());</span>
00258         <span class="comment">//Real fSamplePosZ = m_fScale * (rkPos.z() + m_kOffset.z());</span>
00259 
00260         <a class="code" href="namespacedg.html#a28">Real</a> fSamplePosX = rkPos.x();
00261         <a class="code" href="namespacedg.html#a28">Real</a> fSamplePosY = rkPos.y();
00262         <a class="code" href="namespacedg.html#a28">Real</a> fSamplePosZ = rkPos.z();
00263 
00264         <a class="code" href="namespacedg.html#a28">Real</a> fDensity = 0;
00265         <span class="keywordflow">if</span>(m_pvFilteredDensityFn)
00266         {
00267                 fDensity = m_pvFilteredDensityFn(
00268                                                 fSamplePosX * fNoiseFreq,
00269                                                 fSamplePosY * fNoiseFreq,
00270                                                 fSamplePosZ * fNoiseFreq,
00271                                                 fStepSize * fNoiseFreq );
00272         }
00273         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(m_pvDensityFn)
00274         {
00275                 fDensity = m_pvDensityFn(
00276                                                 fSamplePosX * fNoiseFreq,
00277                                                 fSamplePosY * fNoiseFreq,
00278                                                 fSamplePosZ * fNoiseFreq);
00279         }
00280 
00281         <span class="keywordflow">if</span>(m_bKeepInView)
00282         {
00283                 <span class="comment">// apply the density to a sphere at the camera's look point</span>
00284                 Vector kRV = rkPos + m_pkCamera-&gt;getPosition() + m_pkCamera-&gt;getDirection();
00285                 fRadius = 0.5 * <a class="code" href="namespacedg.html#a182">Dot</a>( kRV, kRV );
00286                 fDensity += 1.0 - fRadius * fRadius;
00287         }
00288         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(m_bFadeOut)
00289         {
00290                 <span class="comment">// fade out at sphere</span>
00291                 fDensity *= 1.0 - <a class="code" href="namespacedg.html#a156">SmoothStep</a>(0.8, 1.0, rkPos.length() / fRadius);
00292         }
00293 
00294         <span class="keywordflow">return</span> fDensity;
00295 }
00296 <span class="comment">//******************************************************************************</span>
00297 Color Hypertexture::computeColor(
00298         <span class="keyword">const</span> Vector&amp; rkPos, <a class="code" href="namespacedg.html#a28">Real</a> fStepSize)
00299 {
00300         <span class="keywordflow">if</span>(m_pvFilteredColorFn)
00301         {
00302                 <span class="keywordflow">return</span> m_pvFilteredColorFn( rkPos.x(), rkPos.y(), rkPos.z(), fStepSize );
00303         }
00304         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(m_pvColorFn)
00305         {
00306                 <span class="keywordflow">return</span> m_pvColorFn( rkPos.x(), rkPos.y(), rkPos.z() );
00307         }
00308         <span class="keywordflow">return</span> Color::WHITE;
00309 }
00310 <span class="comment">//******************************************************************************</span>
00311 <a class="code" href="namespacedg.html#a28">Real</a> Hypertexture::computeShadow(
00312         <span class="keyword">const</span> Vector&amp; rkPos, <span class="keyword">const</span> Vector&amp; rkNormal, <span class="keyword">const</span> Vector&amp; rkRay,
00313         <a class="code" href="namespacedg.html#a28">Real</a> fRadius, <a class="code" href="namespacedg.html#a28">Real</a> fLightDensity,
00314         <a class="code" href="namespacedg.html#a28">Real</a> fNoiseFreq, <a class="code" href="namespacedg.html#a28">Real</a> fStepSize, <a class="code" href="namespacedg.html#a28">Real</a> fThreshold)
00315 {
00316         <span class="comment">// only shade the back, not the front</span>
00317         <span class="keywordflow">if</span>(<a class="code" href="namespacedg.html#a182">Dot</a>(rkNormal, rkRay) &lt; 0)
00318                 <span class="keywordflow">return</span> 0.0;
00319 
00320         <a class="code" href="namespacedg.html#a28">Real</a> fAccumOpacity = 0;
00321         <a class="code" href="namespacedg.html#a28">Real</a> fRayLen = rkRay.length();
00322         Vector kRayDir = <a class="code" href="namespacedg.html#a186">Normalize</a>(rkRay);
00323 
00324         <span class="comment">// check sphere for intersection points to determine start and end</span>
00325         <a class="code" href="namespacedg.html#a28">Real</a> fT0, fT1;
00326         <a class="code" href="namespacedg.html#a28">Real</a> fHits = <a class="code" href="namespacedg.html#a177">RaySphere</a>(rkPos, rkRay, fRadius, m_fRayEpsilon, fT0, fT1);
00327 
00328         <span class="comment">// determine the distance to march</span>
00329         <a class="code" href="namespacedg.html#a28">Real</a> fEnd = (fHits &gt; 0) ? fT0 : 0;
00330         fEnd = <a class="code" href="namespacedg.html#a105">Min</a>(fEnd, fRayLen);
00331 
00332         <span class="comment">// get the start density</span>
00333         <a class="code" href="namespacedg.html#a28">Real</a> fDistance = 0;
00334         <a class="code" href="namespacedg.html#a28">Real</a> fStride = <a class="code" href="namespacedg.html#a105">Min</a>(fStepSize, fEnd - fDistance);
00335         <a class="code" href="namespacedg.html#a28">Real</a> fPrevDensity = computeDensity(rkPos, fRadius, fNoiseFreq, fStepSize);
00336 
00337         <span class="comment">// sharpen at volume boundary</span>
00338         fPrevDensity = <a class="code" href="namespacedg.html#a156">SmoothStep</a>(fThreshold,
00339                                                           fThreshold + ms_fBoundaryOffset,
00340                                                           fPrevDensity);
00341 
00342         <span class="comment">// continue marching until we reach the end or total opacity</span>
00343         <span class="keywordflow">while</span> (fDistance &lt;= fEnd &amp;&amp; fAccumOpacity &lt; m_fOpacityThreshold)
00344         {
00345                 <span class="comment">// take a step and get the scattered light and density</span>
00346                 fStride = <a class="code" href="namespacedg.html#a62">Clamp</a>(fStride, ms_fMinStride, fEnd - fDistance);
00347                 fDistance += fStride;
00348 
00349                 <span class="comment">// compute the sample position</span>
00350                 Vector kSamplePos = rkPos + fDistance * kRayDir;
00351 
00352                 <span class="comment">// compute the current density</span>
00353                 <a class="code" href="namespacedg.html#a28">Real</a> fCurrentDensity = computeDensity(kSamplePos, fRadius,
00354                                                                                    fNoiseFreq, fStepSize);
00355 
00356                 <span class="comment">// sharpen at volume boundary</span>
00357                 fCurrentDensity = <a class="code" href="namespacedg.html#a156">SmoothStep</a>(fThreshold,
00358                                                                          fThreshold + ms_fBoundaryOffset,
00359                                                                          fCurrentDensity);
00360 
00361                 <span class="comment">// compute the optical path length</span>
00362                 <a class="code" href="namespacedg.html#a28">Real</a> fTau = fLightDensity * fStride / 2.0 *
00363                                         (fCurrentDensity + fPrevDensity);
00364 
00365                 <span class="comment">// accumulate the opacity with exponential decay</span>
00366                 fAccumOpacity += (1 - fAccumOpacity) * (1 - <a class="code" href="namespacedg.html#a93">Exp</a>( -fTau));
00367 
00368                 <span class="comment">// setup for next iteration</span>
00369                 fPrevDensity = fCurrentDensity;
00370         }
00371 
00372         <span class="comment">// return the accumulated result</span>
00373         <span class="keywordflow">return</span> fAccumOpacity;
00374 }
00375 <span class="comment">//******************************************************************************</span>
00376 Color Hypertexture::computeShading(
00377         <span class="keyword">const</span> Vector&amp; rkPos, <span class="keyword">const</span> Vector&amp; rkRayDir,
00378         <a class="code" href="namespacedg.html#a28">Real</a> fIncomingDensity, <a class="code" href="namespacedg.html#a28">Real</a> fRadius, <a class="code" href="namespacedg.html#a28">Real</a> fDensity,
00379         <a class="code" href="namespacedg.html#a28">Real</a> fNoiseFreq, <a class="code" href="namespacedg.html#a28">Real</a> fStepSize, <a class="code" href="namespacedg.html#a28">Real</a> fThreshold)
00380 {
00381         <span class="comment">// compute the surface normal at the current position</span>
00382         Vector kSurfaceNormal = computeNormal(rkPos, fIncomingDensity,
00383                                                                                   fNoiseFreq, fRadius, fStepSize);
00384 
00385         <span class="comment">// get the forward facing normal and normalize it</span>
00386         kSurfaceNormal = <a class="code" href="namespacedg.html#a179">FaceForward</a>(kSurfaceNormal, rkRayDir);
00387         kSurfaceNormal = <a class="code" href="namespacedg.html#a186">Normalize</a>(kSurfaceNormal);
00388 
00389         <span class="comment">// setup for computing the color of the scattered light</span>
00390         Color kLightScatter = m_kLightColor;
00391 
00392         <span class="comment">// compute shadow if necessary</span>
00393         <span class="keywordflow">if</span> (fDensity &gt; 0)
00394         {
00395                 kLightScatter *= 1.0f - computeShadow(rkPos, kSurfaceNormal,
00396                                                                                           m_kLightDirection, fRadius,
00397                                                                                           fDensity, fNoiseFreq, fStepSize,
00398                                                                                           fThreshold);
00399         }
00400 
00401         <span class="comment">// shade the surface if necessary</span>
00402         <span class="keywordflow">if</span>(m_pvShadeFn)
00403         {
00404                 <span class="comment">// get the normal for the light direction</span>
00405                 Vector kLightNormal = <a class="code" href="namespacedg.html#a186">Normalize</a>(m_kLightDirection);
00406                 Vector kViewNormal = <a class="code" href="namespacedg.html#a186">Normalize</a>(rkRayDir);
00407 
00408                 <span class="comment">// do the shading calculation</span>
00409                 Color kShadedColor = m_pvShadeFn(kSurfaceNormal, kViewNormal,
00410                                                                                  kLightNormal, m_kLightColor,
00411                                                                                  kLightScatter, m_fAmbient,
00412                                                                                  m_fDiffuse, m_fSpecular, m_fRoughness );
00413 
00414                 <span class="comment">// combine the shaded light with the surface color</span>
00415                 <span class="keywordflow">return</span> kShadedColor * computeColor(rkPos, fStepSize);
00416         }
00417 
00418         <span class="comment">// otherwise just combine the shadowed light with the surface color</span>
00419         <span class="keywordflow">return</span> kLightScatter * computeColor(rkPos, fStepSize);
00420 }
00421 <span class="comment">//******************************************************************************</span>
00422 Vector Hypertexture::computeNormal(
00423         <span class="keyword">const</span> Vector &amp; rkPos, <a class="code" href="namespacedg.html#a28">Real</a> fDensity,
00424         <a class="code" href="namespacedg.html#a28">Real</a> fNoiseFreq, <a class="code" href="namespacedg.html#a28">Real</a> fRadius, <a class="code" href="namespacedg.html#a28">Real</a> fStepSize)
00425 {
00426         Vector kNormal;
00427         <span class="keywordflow">if</span>( rkPos.length() &gt; fRadius - 0.0051)
00428         {
00429                 kNormal = rkPos;
00430         }
00431         <span class="keywordflow">else</span>
00432         {
00433                 kNormal = (computeDensity(rkPos + Vector(fStepSize / 10.0, 0, 0),
00434                                                    fRadius, fNoiseFreq, fStepSize) - fDensity,
00435                                    computeDensity(rkPos + Vector(0, fStepSize / 10.0, 0),
00436                                                    fRadius, fNoiseFreq, fStepSize) - fDensity,
00437                                    computeDensity(rkPos + Vector(0, 0, fStepSize / 10.0),
00438                                                    fRadius, fNoiseFreq, fStepSize) - fDensity);
00439         }
00440 
00441         <span class="keywordflow">return</span> <a class="code" href="namespacedg.html#a186">Normalize</a>(kNormal);
00442 }
00443 <span class="comment">//******************************************************************************</span>
00444 
</pre></div>		<div class="footer" width="100%">
		<hr>
			<a href="http://lyon-smith.org/">&copy; Derek Gerstmann - NCCA - Bournemouth University - 2004</a>
		</div>
		<br>
	</body>
</html>
