<html>
	<head>
		<title>Branch - API Documentation</title>
		<link HREF="style.css" REL="stylesheet" TYPE="text/css">
	</head>
	<body>
		<div width="100%" height="40px" class="banner">
			Visualizer - API Documentation
		</div>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>Tracer.cpp</h1><a href="Tracer_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="preprocessor">#include "<a class="code" href="Tracer_8h.html">Tracer.h</a>"</span>
00002 <span class="preprocessor">#include "<a class="code" href="Maths_8h.html">Maths.h</a>"</span>
00003 <span class="preprocessor">#include "<a class="code" href="Shading_8h.html">Shading.h</a>"</span>
00004 <span class="preprocessor">#include &lt;memory&gt;</span>
00005 
00006 <span class="keyword">using</span> <span class="keyword">namespace </span>dg;
00007 <span class="comment">//******************************************************************************</span>
<a name="l00008"></a><a class="code" href="classdg_1_1Tracer.html#a0">00008</a> Tracer::Tracer(Function pvFunction, <a class="code" href="classdg_1_1Camera.html">Camera</a>* pkCamera)
00009         :       m_kLightColor(1.0f, 1.0f, 1.0f),
00010                 m_kBaseColor(1.0f, 1.0f, 1.0f, 1.0f)
00011 {
00012         m_fNormalEpsilon = 0.01;
00013         m_fRayEpsilon = 1.0e-4f;
00014         m_fIsoLevel = 0.0f;
00015         m_bBlur = <span class="keyword">false</span>;
00016 
00017         m_fAmbient = 0.127;
00018         m_fDiffuse = 1;
00019         m_fSpecular = 0.3;
00020         m_fRoughness = 0.1;
00021 
00022         m_pvFunction = pvFunction;
00023         m_pkCamera = pkCamera;
00024 }
00025 <span class="comment">//******************************************************************************</span>
<a name="l00026"></a><a class="code" href="classdg_1_1Tracer.html#a1">00026</a> Tracer::~Tracer ()
00027 {
00028         <span class="comment">// EMPTY!</span>
00029 }
00030 <span class="comment">//******************************************************************************</span>
<a name="l00031"></a><a class="code" href="classdg_1_1Tracer.html#a32">00031</a> <span class="keywordtype">void</span> Tracer::render()
00032 {
00033         <span class="keywordflow">if</span>(!m_pvFunction || !m_pkCamera)
00034                 <span class="keywordflow">return</span>;
00035 
00036         <span class="comment">// get the image from the camera</span>
00037         <a class="code" href="classdg_1_1Image.html">Image</a>* pkImage = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a28">getImage</a>();
00038         <span class="keywordflow">if</span>(!pkImage)
00039                 <span class="keywordflow">return</span>;
00040 
00041         <a class="code" href="classdg_1_1Tracer.html#a32">render</a>(0, pkImage-&gt;<a class="code" href="classdg_1_1Image.html#a9">height</a>());
00042 
00043         <span class="keywordflow">if</span> ( m_bBlur )
00044                 pkImage-&gt;<a class="code" href="classdg_1_1Image.html#a23">blur</a>();
00045 }
00046 <span class="comment">//******************************************************************************</span>
<a name="l00047"></a><a class="code" href="classdg_1_1Tracer.html#a33">00047</a> <span class="keywordtype">void</span> Tracer::render(<a class="code" href="namespacedg.html#a15">UInt</a> uiStartLine, <a class="code" href="namespacedg.html#a15">UInt</a> uiEndLine)
00048 {
00049         <span class="keywordflow">if</span>(!m_pvFunction || !m_pkCamera)
00050                 <span class="keywordflow">return</span>;
00051 
00052         <span class="comment">// get the image from the camera</span>
00053         <a class="code" href="classdg_1_1Image.html">Image</a>* pkImage = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a28">getImage</a>();
00054         <span class="keywordflow">if</span>(!pkImage)
00055                 <span class="keywordflow">return</span>;
00056 
00057         <span class="comment">// get the image size</span>
00058         <a class="code" href="namespacedg.html#a15">UInt</a> uiWidth = pkImage-&gt;<a class="code" href="classdg_1_1Image.html#a8">width</a>();
00059         <a class="code" href="namespacedg.html#a15">UInt</a> uiHeight = pkImage-&gt;<a class="code" href="classdg_1_1Image.html#a9">height</a>();
00060 
00061         <span class="comment">// get the clipping planes</span>
00062         <a class="code" href="namespacedg.html#a28">Real</a> fNear = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a12">getNear</a>();
00063         <a class="code" href="namespacedg.html#a28">Real</a> fFar = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a14">getFar</a>();
00064         <a class="code" href="namespacedg.html#a28">Real</a> fHW = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a16">getHalfWidth</a>();
00065         <a class="code" href="namespacedg.html#a28">Real</a> fHH = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a20">getHalfHeight</a>();
00066 
00067         <span class="comment">// get the camera frame</span>
00068         <a class="code" href="classdg_1_1Vector.html">Vector</a> kCamPos = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a3">getPosition</a>();
00069         <a class="code" href="classdg_1_1Vector.html">Vector</a> kCamDir = <a class="code" href="namespacedg.html#a186">Normalize</a>(m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a5">getDirection</a>());
00070         <a class="code" href="classdg_1_1Vector.html">Vector</a> kCamRight = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a9">getRight</a>();
00071         <a class="code" href="classdg_1_1Vector.html">Vector</a> kCamUp = m_pkCamera-&gt;<a class="code" href="classdg_1_1Camera.html#a7">getUp</a>();
00072 
00073         <span class="comment">// calculate the increment for ray marching (fixed size)</span>
00074         <a class="code" href="namespacedg.html#a28">Real</a> fMultX = 2.0 / (uiWidth - 1.0f);
00075         <a class="code" href="namespacedg.html#a28">Real</a> fMultY = 2.0 / (uiHeight - 1.0f);
00076         <a class="code" href="namespacedg.html#a28">Real</a> fIncrement = (fFar - fNear)/(fNear*(m_uiSamples - 1.0));
00077 
00078         <span class="comment">// setup for gathering statistics</span>
00079         m_uiRayHits = 0;
00080 
00081         <span class="comment">// render each scanline from top to bottom</span>
00082         <span class="keywordflow">for</span>( <a class="code" href="namespacedg.html#a15">UInt</a> uiY = uiStartLine; uiY &lt; uiEndLine &amp;&amp; uiY &lt; uiHeight; uiY++ )
00083         {
00084                 <span class="comment">// calculate the pixels location</span>
00085                 <a class="code" href="namespacedg.html#a28">Real</a> fY = fHH * (-1.0f + fMultY * uiY);
00086 
00087                 <span class="comment">// render the scanline</span>
00088                 <span class="keywordflow">for</span>( <a class="code" href="namespacedg.html#a15">UInt</a> uiX = 0; uiX &lt; uiWidth; uiX++ )
00089                 {
00090                         <span class="comment">// calculate the pixels location</span>
00091                         <a class="code" href="namespacedg.html#a28">Real</a> fX = fHW * (-1.0f + fMultX * uiX);
00092 
00093                         <span class="comment">// compute ray direction starting from near clip plane</span>
00094                         <a class="code" href="classdg_1_1Vector.html">Vector</a> kRayDir = fNear * kCamDir + fX * kCamRight + fY * kCamUp;
00095 
00096                         <span class="comment">// set the background color</span>
00097                         pkImage-&gt;<a class="code" href="classdg_1_1Image.html#a19">setColor</a>(uiX, uiY, m_kBgColor);
00098 
00099                         <span class="comment">// integrate across the surface</span>
00100                         <a class="code" href="classdg_1_1Color.html">Color</a> kColor;
00101                         integrate( kCamPos, kRayDir, fIncrement, kColor );
00102 
00103                         <span class="comment">// update the image</span>
00104                         pkImage-&gt;<a class="code" href="classdg_1_1Image.html#a19">setColor</a>(uiX, uiY, kColor);
00105                 }
00106         }
00107 }
00108 <span class="comment">//******************************************************************************</span>
00109 <span class="keywordtype">void</span> Tracer::integrate(
00110         Vector&amp; rkPos, Vector&amp; rkRayDir, <a class="code" href="namespacedg.html#a28">Real</a> fIncrement, Color&amp; rkSampleColor)
00111 {
00112         <span class="comment">// compute a value for the start point of the ray</span>
00113         <a class="code" href="namespacedg.html#a28">Real</a> fDist1 = 1.0;              <span class="comment">// start at 1.0</span>
00114         Vector kPos1 = rkPos;
00115         <a class="code" href="namespacedg.html#a28">Real</a> fValue1 = sample( kPos1.x(), kPos1.y(), kPos1.z());
00116 
00117         <span class="comment">// normalize the current light direction for later use</span>
00118         Vector kLightNormal = <a class="code" href="namespacedg.html#a186">Normalize</a>(m_kLightDirection);
00119 
00120         <span class="comment">// continue sampling until all samples are covered</span>
00121         <span class="keywordflow">for</span>(<a class="code" href="namespacedg.html#a15">UInt</a> uiS = 0; uiS &lt; m_uiSamples; uiS++)
00122         {
00123                 <span class="comment">// compute a value for next increment</span>
00124                 <a class="code" href="namespacedg.html#a28">Real</a> fDist2 = 1.0 + fIncrement * uiS;
00125                 Vector kPos2 = rkPos + fDist2 * rkRayDir;
00126                 <a class="code" href="namespacedg.html#a28">Real</a> fValue2 = sample(kPos2.x(), kPos2.y(), kPos2.z());
00127 
00128                 <span class="comment">//if ( fF0*fF1 &lt;= m_fIsoLevel )</span>
00129                 <span class="keywordflow">if</span>( fValue1 * fValue2 &lt;= 0.0 )
00130                 {
00131                         <span class="comment">// do a simple bisect to find the inersection with the surface</span>
00132                         Vector kPos, kSurfaceNormal;
00133                         computeIntersection(
00134                                 fDist1, fValue1, kPos1,
00135                                 fDist2, fValue2, kPos2,
00136                                 rkRayDir, kPos, kSurfaceNormal);
00137 
00138                         <span class="comment">// normalize the current ray dir and reverse it for view dir</span>
00139                         Vector kViewNormal = -<a class="code" href="namespacedg.html#a186">Normalize</a>(rkRayDir);
00140 
00141                         <span class="comment">// get the forward facing normal</span>
00142                         kSurfaceNormal = <a class="code" href="namespacedg.html#a179">FaceForward</a>(kSurfaceNormal, kViewNormal);
00143 
00144                         <span class="comment">// shade the sample using standard phong shading (plastic-like)</span>
00145                         rkSampleColor = <a class="code" href="namespacedg.html#a176">Phong</a>( kSurfaceNormal, kViewNormal,
00146                                                                    kLightNormal,m_kLightColor, m_kBaseColor,
00147                                                                    m_fAmbient, m_fDiffuse, m_fSpecular,
00148                                                                    m_fRoughness );
00149 
00150                         <span class="comment">// increment stats counter</span>
00151                         m_uiRayHits++;
00152                         <span class="keywordflow">return</span>;
00153                 }
00154 
00155                 <span class="comment">// offset for next sample</span>
00156                 fDist1 = fDist2;
00157                 kPos1 = kPos2;
00158                 fValue1 = fValue2;
00159         }
00160 }
00161 <span class="comment">//******************************************************************************</span>
00162 <span class="keywordtype">void</span> Tracer::computeIntersection(
00163         <a class="code" href="namespacedg.html#a28">Real</a> fDist1, <a class="code" href="namespacedg.html#a28">Real</a> fValue1, <span class="keyword">const</span> Vector&amp; rkPos1,
00164         <a class="code" href="namespacedg.html#a28">Real</a> fDist2, <a class="code" href="namespacedg.html#a28">Real</a> fValue2, <span class="keyword">const</span> Vector&amp; rkPos2,
00165         <span class="keyword">const</span> Vector&amp; rkRayDir, Vector&amp; rkPos, Vector&amp; rkNormal)
00166 {
00167         <span class="comment">// return if value1 intersects</span>
00168         <span class="keywordflow">if</span> ( <a class="code" href="namespacedg.html#a90">Abs</a>(fValue1) &lt;= m_fRayEpsilon )
00169         {
00170                 rkPos = rkPos1;
00171                 rkNormal = computeNormal(rkPos.x(), rkPos.y(), rkPos.z());
00172                 <span class="keywordflow">return</span>;
00173         }
00174 
00175         <span class="comment">// return if value1 intersects</span>
00176         <span class="keywordflow">if</span> ( <a class="code" href="namespacedg.html#a90">Abs</a>(fValue2) &lt;= m_fRayEpsilon )
00177         {
00178                 rkPos = rkPos2;
00179                 rkNormal = computeNormal(rkPos.x(), rkPos.y(), rkPos.z());
00180                 <span class="keywordflow">return</span>;
00181         }
00182 
00183         <span class="comment">// bisect until an intersection is found or max iterations are reached</span>
00184         <span class="keyword">const</span> <a class="code" href="namespacedg.html#a15">UInt</a> uiMax = 8;
00185         <span class="keywordflow">for</span>(<a class="code" href="namespacedg.html#a15">UInt</a> i = 0; i &lt; uiMax; i++)
00186         {
00187                 <a class="code" href="namespacedg.html#a28">Real</a> fD = 0.5f * (fDist1 + fDist2);
00188                 rkPos = m_pkCamera-&gt;getPosition() + fD * rkRayDir;
00189                 <a class="code" href="namespacedg.html#a28">Real</a> fV = sample(rkPos.x(), rkPos.y(), rkPos.z());
00190 
00191                 <span class="comment">// stop if value intersects</span>
00192                 <span class="keywordflow">if</span> ( <a class="code" href="namespacedg.html#a90">Abs</a>(fV) &lt;= m_fRayEpsilon )
00193                         <span class="keywordflow">break</span>;
00194 
00195                 <span class="comment">//if ( fV*fValue1 &lt; m_fIsoLevel )</span>
00196                 <span class="keywordflow">if</span> ( fV * fValue1 &lt; 0.0 )
00197                 {
00198                         fDist2 = fD;
00199                         fValue2 = fV;
00200                 }
00201                 <span class="keywordflow">else</span>
00202                 {
00203                         fDist1 = fD;
00204                         fValue1 = fV;
00205                 }
00206         }
00207 
00208         <span class="comment">// get a normal for the current position</span>
00209         rkNormal = computeNormal(rkPos.x(), rkPos.y(), rkPos.z());
00210 }
00211 <span class="comment">//******************************************************************************</span>
00212 Vector Tracer::computeNormal(<a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ)
00213 {
00214         Vector kNormal;
00215         kNormal.x() = sample(fX - m_fNormalEpsilon, fY, fZ) -
00216                                   sample(fX + m_fNormalEpsilon, fY, fZ);
00217 
00218         kNormal.y() = sample(fX, fY - m_fNormalEpsilon, fZ) -
00219                                   sample(fX, fY + m_fNormalEpsilon, fZ);
00220 
00221         kNormal.z() = sample(fX, fY, fZ - m_fNormalEpsilon) -
00222                                   sample(fX, fY, fZ + m_fNormalEpsilon);
00223         <a class="code" href="namespacedg.html#a186">Normalize</a>(kNormal);
00224         <span class="keywordflow">return</span> kNormal;
00225 }
00226 <span class="comment">//******************************************************************************</span>
00227 
</pre></div>		<div class="footer" width="100%">
		<hr>
			<a href="http://lyon-smith.org/">&copy; Derek Gerstmann - NCCA - Bournemouth University - 2004</a>
		</div>
		<br>
	</body>
</html>
