<html>
	<head>
		<title>Branch - API Documentation</title>
		<link HREF="style.css" REL="stylesheet" TYPE="text/css">
	</head>
	<body>
		<div width="100%" height="40px" class="banner">
			Visualizer - API Documentation
		</div>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>Procedural.cpp</h1><a href="Procedural_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">// #############################################################################</span>
00002 <span class="comment">// # Operators.h - Basic procedural functions for pixel manipulation</span>
00003 <span class="comment">// #</span>
00004 <span class="comment">// # Created    : May 2004</span>
00005 <span class="comment">// # Copyright  : (C) 2004 by Derek Gerstmann</span>
00006 <span class="comment">// # Email              : dgerstma@acm.org</span>
00007 <span class="comment">// #</span>
00008 <span class="comment">// #############################################################################</span>
00009 
00010 <span class="comment">// =============================================================================</span>
00011 <span class="comment">//</span>
00012 <span class="comment">//  This program is free software; you can redistribute it and/or modify</span>
00013 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
00014 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
00015 <span class="comment">//  (at your option) any later version.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">// =============================================================================</span>
00018 
00019 <span class="preprocessor">#include "<a class="code" href="Procedural_8h.html">Procedural.h</a>"</span>
00020 <span class="preprocessor">#include "<a class="code" href="DataTypes_8h.html">DataTypes.h</a>"</span>
00021 <span class="preprocessor">#include "<a class="code" href="RandTables_8h.html">RandTables.h</a>"</span>
00022 <span class="preprocessor">#include "<a class="code" href="Messages_8h.html">Messages.h</a>"</span>
00023 <span class="preprocessor">#include "<a class="code" href="Maths_8h.html">Maths.h</a>"</span>
00024 
00025 <span class="comment">//******************************************************************************</span>
00026 
00027 <span class="keyword">using</span> <span class="keyword">namespace </span>dg;
00028 
00029 <span class="comment">//*****************************************************************************</span>
<a name="l00030"></a><a class="code" href="namespacedg.html#a126">00030</a> <a class="code" href="namespacedg.html#a28">Real</a> <a class="code" href="namespacedg.html#a126">dg::Spline</a>(<a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a15">UInt</a> uiKnots, <a class="code" href="namespacedg.html#a28">Real</a> *apkKnots, <span class="keyword">const</span> <a class="code" href="namespacedg.html#a28">Real</a> afBasis[4][4])
00031 {
00032         <a class="code" href="namespacedg.html#a14">Int</a> iSpan;
00033         <a class="code" href="namespacedg.html#a15">UInt</a> uiSpanCount = uiKnots - 3;
00034 
00035         <span class="keywordflow">if</span> (uiSpanCount &lt; 1)
00036                 <span class="keywordflow">return</span> 0;
00037 
00038         <span class="comment">// Find the appropriate 4-point span of the Spline.</span>
00039         fX = <a class="code" href="namespacedg.html#a62">Clamp</a>(fX, (<a class="code" href="namespacedg.html#a28">Real</a>)0.0, (<a class="code" href="namespacedg.html#a28">Real</a>)1.0) * uiSpanCount;
00040         iSpan = (Int) fX;
00041 
00042         <span class="keywordflow">if</span> (iSpan &gt;= (Int)uiKnots - 3)
00043                 iSpan = (Int)uiKnots - 3;
00044 
00045         fX -= iSpan;
00046         apkKnots += iSpan;
00047 
00048         <span class="comment">// evaluate with appropriate basis</span>
00049         <span class="keywordflow">return</span> <a class="code" href="namespacedg.html#a118">CubicSpan</a>(fX, apkKnots, afBasis);
00050 }
00051 <span class="comment">//******************************************************************************</span>
<a name="l00052"></a><a class="code" href="namespacedg.html#a127">00052</a> <a class="code" href="namespacedg.html#a28">Real</a> <a class="code" href="namespacedg.html#a127">dg::CellNoise</a>( <a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ )
00053 {
00054         <a class="code" href="namespacedg.html#a15">UInt</a> iX = (Int)<a class="code" href="namespacedg.html#a94">Floor</a>(fX);
00055         <a class="code" href="namespacedg.html#a15">UInt</a> iY = (Int)<a class="code" href="namespacedg.html#a94">Floor</a>(fY);
00056         <a class="code" href="namespacedg.html#a15">UInt</a> iZ = (Int)<a class="code" href="namespacedg.html#a94">Floor</a>(fZ);
00057         <a class="code" href="namespacedg.html#a15">UInt</a> iHash = <a class="code" href="namespacedg.html#a147">Hash</a>(iX, iY, iZ);
00058         <span class="keywordflow">return</span> <a class="code" href="namespacedg.html#a145">r</a>(iHash);
00059 }
00060 <span class="comment">//******************************************************************************</span>
<a name="l00061"></a><a class="code" href="namespacedg.html#a128">00061</a> <a class="code" href="namespacedg.html#a28">Real</a> <a class="code" href="namespacedg.html#a128">dg::GradientNoise</a>(<a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ)
00062 {
00063         <a class="code" href="namespacedg.html#a14">Int</a> iX, iY, iZ;
00064         <a class="code" href="namespacedg.html#a28">Real</a> fX0, fX1, fY0, fY1, fZ0, fZ1;
00065         <a class="code" href="namespacedg.html#a28">Real</a> fWX, fWY, fWZ;
00066         <a class="code" href="namespacedg.html#a28">Real</a> fVX0, fVX1, fVY0, fVY1, fVZ0, fVZ1;
00067 
00068         iX = (Int)<a class="code" href="namespacedg.html#a94">Floor</a>(fX);
00069         fX0 = fX - iX;
00070         fX1 = fX0 - 1;
00071         fWX = <a class="code" href="namespacedg.html#a152">Cubic</a>(fX0);
00072 
00073         iY = (Int)<a class="code" href="namespacedg.html#a94">Floor</a>(fY);
00074         fY0 = fY - iY;
00075         fY1 = fY0 - 1;
00076         fWY = <a class="code" href="namespacedg.html#a152">Cubic</a>(fY0);
00077 
00078         iZ = (Int)<a class="code" href="namespacedg.html#a94">Floor</a>(fZ);
00079         fZ0 = fZ - iZ;
00080         fZ1 = fZ0 - 1;
00081         fWZ = <a class="code" href="namespacedg.html#a152">Cubic</a>(fZ0);
00082 
00083         fVX0 = <a class="code" href="namespacedg.html#a149">Gradient</a>(iX, iY, iZ, fX0, fY0, fZ0);
00084         fVX1 = <a class="code" href="namespacedg.html#a149">Gradient</a>(iX + 1, iY, iZ, fX1, fY0, fZ0);
00085 
00086         fVY0 = <a class="code" href="namespacedg.html#a154">Lerp</a>(fWX, fVX0, fVX1);
00087 
00088         fVX0 = <a class="code" href="namespacedg.html#a149">Gradient</a>(iX, iY + 1, iZ, fX0, fY1, fZ0);
00089         fVX1 = <a class="code" href="namespacedg.html#a149">Gradient</a>(iX + 1, iY + 1, iZ, fX1, fY1, fZ0);
00090 
00091         fVY1 = <a class="code" href="namespacedg.html#a154">Lerp</a>(fWX, fVX0, fVX1);
00092         fVZ0 = <a class="code" href="namespacedg.html#a154">Lerp</a>(fWY, fVY0, fVY1);
00093 
00094         fVX0 = <a class="code" href="namespacedg.html#a149">Gradient</a>(iX, iY, iZ + 1, fX0, fY0, fZ1);
00095         fVX1 = <a class="code" href="namespacedg.html#a149">Gradient</a>(iX + 1, iY, iZ + 1, fX1, fY0, fZ1);
00096 
00097         fVY0 = <a class="code" href="namespacedg.html#a154">Lerp</a>(fWX, fVX0, fVX1);
00098 
00099         fVX0 = <a class="code" href="namespacedg.html#a149">Gradient</a>(iX, iY + 1, iZ + 1, fX0, fY1, fZ1);
00100         fVX1 = <a class="code" href="namespacedg.html#a149">Gradient</a>(iX + 1, iY + 1, iZ + 1, fX1, fY1, fZ1);
00101 
00102         fVY1 = <a class="code" href="namespacedg.html#a154">Lerp</a>(fWX, fVX0, fVX1);
00103         fVZ1 = <a class="code" href="namespacedg.html#a154">Lerp</a>(fWY, fVY0, fVY1);
00104 
00105         <span class="keywordflow">return</span> 1.0 - 2.0 * <a class="code" href="namespacedg.html#a154">Lerp</a>(fWZ, fVZ0, fVZ1);
00106         <span class="comment">//return Lerp(fWZ, fVZ0, fVZ1);</span>
00107 
00108 }
00109 <span class="comment">//******************************************************************************</span>
<a name="l00110"></a><a class="code" href="namespacedg.html#a129">00110</a> <a class="code" href="namespacedg.html#a28">Real</a> <a class="code" href="namespacedg.html#a129">dg::ValueNoise</a>(<a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ, <span class="keyword">const</span> <a class="code" href="namespacedg.html#a28">Real</a> afBasis[4][4])
00111 {
00112         <a class="code" href="namespacedg.html#a14">Int</a> i, j, k;
00113         <a class="code" href="namespacedg.html#a14">Int</a> iX, iY, iZ;
00114         <a class="code" href="namespacedg.html#a28">Real</a> fRX, fRY, fRZ;
00115         <a class="code" href="namespacedg.html#a28">Real</a> afKnotsX[4], afKnotsY[4], afKnotsZ[4];
00116 
00117         iX = (Int)floor(fX);
00118         fRX = fX - iX;
00119 
00120         iY = (Int)floor(fY);
00121         fRY = fY - iY;
00122 
00123         iZ = (Int)floor(fZ);
00124         fRZ = fZ - iZ;
00125 
00126         <span class="keywordflow">for</span> (k = -1; k &lt;= 2; k++)
00127         {
00128                 <span class="keywordflow">for</span> (j = -1; j &lt;= 2; j++)
00129                 {
00130                         <span class="keywordflow">for</span> (i = -1; i &lt;= 2; i++)
00131                         {
00132                                 afKnotsX[i + 1] = <a class="code" href="namespacedg.html#a148">Lattice</a>(iX + i, iY + j, iZ + k);
00133                         }
00134                         afKnotsY[j + 1] = <a class="code" href="namespacedg.html#a126">Spline</a>(fRX, 4, afKnotsX, afBasis);
00135                 }
00136                 afKnotsZ[k + 1] = <a class="code" href="namespacedg.html#a126">Spline</a>(fRY, 4, afKnotsY, afBasis);
00137         }
00138         <span class="keywordflow">return</span> <a class="code" href="namespacedg.html#a126">Spline</a>(fRZ, 4, afKnotsZ, afBasis);
00139 }
00140 <span class="comment">//******************************************************************************</span>
<a name="l00141"></a><a class="code" href="namespacedg.html#a130">00141</a> <a class="code" href="namespacedg.html#a28">Real</a> <a class="code" href="namespacedg.html#a130">dg::FractionalBrownianMotion</a>(
00142         <a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ, <a class="code" href="namespacedg.html#a28">Real</a> fIncrement,
00143         <a class="code" href="namespacedg.html#a28">Real</a> fLacunarity, <a class="code" href="namespacedg.html#a28">Real</a> fOctaves)
00144 {
00145         <span class="comment">// static variables for caching spectral weights</span>
00146         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacedg.html#a15">UInt</a> uiMaxOctaves = 32;
00147         <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00148         <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00149         <span class="keyword">static</span> <a class="code" href="namespacedg.html#a28">Real</a> fPrevLacunarity = 0;
00150 
00151         <span class="comment">// precompute and store spectral weights</span>
00152         <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00153         {
00154                 <span class="comment">//  compute weight for each frequency</span>
00155                 <span class="keywordflow">for</span>( <a class="code" href="namespacedg.html#a15">UInt</a> i = 0; i &lt; uiMaxOctaves; i++ )
00156                         afExponents[i] = pow( fLacunarity, (<a class="code" href="namespacedg.html#a28">Real</a>)i * -fIncrement );
00157 
00158                 bInitialized = <span class="keyword">true</span>;
00159                 fPrevLacunarity = fLacunarity;
00160         }
00161 
00162         <span class="comment">// create the fractional brownian motion</span>
00163         <a class="code" href="namespacedg.html#a28">Real</a> fSum = 0;
00164         <a class="code" href="namespacedg.html#a15">UInt</a> i = 0;
00165         <span class="keywordflow">for</span>(i = 0;  i &lt; fOctaves;  i++)
00166         {
00167                 fSum += afExponents[i] * <a class="code" href="namespacedg.html#a128">GradientNoise</a>(fX, fY, fZ);
00168 
00169                 <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00170                 fX *= fLacunarity;
00171                 fY *= fLacunarity;
00172                 fZ *= fLacunarity;
00173         }
00174 
00175         <span class="comment">// take care of remainder in "octaves"</span>
00176         <a class="code" href="namespacedg.html#a28">Real</a> fRemainder = fOctaves - (int)fOctaves;
00177         <span class="keywordflow">if</span> ( fRemainder )
00178         {
00179                 <span class="comment">// "i" and spatial freq. are preset in loop above</span>
00180                 fSum += fRemainder * afExponents[i] * <a class="code" href="namespacedg.html#a128">GradientNoise</a>(fX, fY, fZ);
00181         }
00182         <span class="keywordflow">return</span> fSum;
00183 }
00184 <span class="comment">//******************************************************************************</span>
<a name="l00185"></a><a class="code" href="namespacedg.html#a137">00185</a> <a class="code" href="namespacedg.html#a28">Real</a> <a class="code" href="namespacedg.html#a137">dg::FilteredFBM</a>(
00186         <a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ,
00187         <a class="code" href="namespacedg.html#a28">Real</a> fFilterWidth,
00188         <a class="code" href="namespacedg.html#a28">Real</a> fIncrement,
00189         <a class="code" href="namespacedg.html#a28">Real</a> fLacunarity,
00190         <a class="code" href="namespacedg.html#a28">Real</a> fOctaves)
00191 {
00192         <span class="comment">// static variables for caching spectral weights</span>
00193         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacedg.html#a15">UInt</a> uiMaxOctaves = 32;
00194         <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00195         <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00196         <span class="keyword">static</span> <a class="code" href="namespacedg.html#a28">Real</a> fPrevLacunarity = 0;
00197 
00198         <span class="comment">// precompute and store spectral weights</span>
00199         <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00200         {
00201                 <span class="comment">//  compute weight for each frequency</span>
00202                 <span class="keywordflow">for</span>( <a class="code" href="namespacedg.html#a15">UInt</a> i = 0; i &lt; uiMaxOctaves; i++ )
00203                         afExponents[i] = pow( fLacunarity, (<a class="code" href="namespacedg.html#a28">Real</a>)i * -fIncrement );
00204 
00205                 bInitialized = <span class="keyword">true</span>;
00206                 fPrevLacunarity = fLacunarity;
00207         }
00208 
00209         <span class="comment">// create the fractional brownian motion</span>
00210         <a class="code" href="namespacedg.html#a28">Real</a> fSum = 0;
00211         <a class="code" href="namespacedg.html#a15">UInt</a> i = 0;
00212         <span class="keywordflow">for</span>(i = 0;  i &lt; fOctaves;  i++)
00213         {
00214                 fSum += afExponents[i] * <a class="code" href="namespacedg.html#a165">FilteredGradientNoise</a>(fX, fY, fZ, fFilterWidth);
00215 
00216                 <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00217                 fX *= fLacunarity;
00218                 fY *= fLacunarity;
00219                 fZ *= fLacunarity;
00220 
00221                 fFilterWidth *= fLacunarity;
00222         }
00223 
00224         <span class="comment">// take care of remainder in "octaves"</span>
00225         <a class="code" href="namespacedg.html#a28">Real</a> fRemainder = fOctaves - (int)fOctaves;
00226         <span class="keywordflow">if</span> ( fRemainder )
00227         {
00228                 <span class="comment">// "i" and spatial freq. are preset in loop above</span>
00229                 fSum += fRemainder * afExponents[i] * <a class="code" href="namespacedg.html#a165">FilteredGradientNoise</a>(fX, fY, fZ, fFilterWidth);
00230         }
00231         <span class="keywordflow">return</span> fSum;
00232 }
00233 <span class="comment">//******************************************************************************</span>
<a name="l00234"></a><a class="code" href="namespacedg.html#a131">00234</a> <a class="code" href="namespacedg.html#a28">Real</a> <a class="code" href="namespacedg.html#a131">dg::Turbulence</a>(
00235         <a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ,
00236         <a class="code" href="namespacedg.html#a28">Real</a> fIncrement,
00237         <a class="code" href="namespacedg.html#a28">Real</a> fLacunarity,
00238         <a class="code" href="namespacedg.html#a28">Real</a> fOctaves)
00239 {
00240         <span class="comment">// static variables for caching spectral weights</span>
00241         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacedg.html#a15">UInt</a> uiMaxOctaves = 32;
00242         <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00243         <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00244         <span class="keyword">static</span> <a class="code" href="namespacedg.html#a28">Real</a> fPrevLacunarity = 0;
00245 
00246         <span class="comment">// precompute and store spectral weights</span>
00247         <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00248         {
00249                 <span class="comment">//  compute weight for each frequency</span>
00250                 <span class="keywordflow">for</span>( <a class="code" href="namespacedg.html#a15">UInt</a> i = 0; i &lt; uiMaxOctaves; i++ )
00251                         afExponents[i] = pow( fLacunarity, (<a class="code" href="namespacedg.html#a28">Real</a>)i * -fIncrement );
00252 
00253                 bInitialized = <span class="keyword">true</span>;
00254                 fPrevLacunarity = fLacunarity;
00255         }
00256 
00257         <a class="code" href="namespacedg.html#a15">UInt</a> i = 0;
00258         <a class="code" href="namespacedg.html#a28">Real</a> fTemp, fValue, fRemainder;
00259 
00260         fValue = 0.0;
00261         fTemp = 0.0;
00262 
00263         <span class="comment">// inner loop of spectral construction, where the fractal is built</span>
00264         <span class="keywordflow">for</span> (i = 0; i &lt; fOctaves; i++)
00265         {
00266                 <span class="comment">// calculate the signal contribution</span>
00267                 fTemp = <a class="code" href="namespacedg.html#a128">GradientNoise</a>(fX, fY, fZ) * afExponents[i];
00268 
00269                 <span class="comment">// accumulate the result</span>
00270                 fValue += <a class="code" href="namespacedg.html#a90">Abs</a>(fTemp);
00271 
00272                 <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00273                 fX *= fLacunarity;
00274                 fY *= fLacunarity;
00275                 fZ *= fLacunarity;
00276         }
00277 
00278         <span class="comment">// take care of remainder in "octaves"</span>
00279         fRemainder = fOctaves - (int)fOctaves;
00280         <span class="keywordflow">if</span> ( fRemainder )
00281         {
00282                 <span class="comment">// "i" and spatial freq. are preset in loop above</span>
00283                 fTemp = fRemainder * <a class="code" href="namespacedg.html#a128">GradientNoise</a>(fX, fY, fZ) * afExponents[i];
00284 
00285                 <span class="comment">// accumulate the result</span>
00286                 fValue += <a class="code" href="namespacedg.html#a90">Abs</a>(fTemp);
00287         }
00288         <span class="keywordflow">return</span>( fValue );
00289 }
00290 <span class="comment">//******************************************************************************</span>
<a name="l00291"></a><a class="code" href="namespacedg.html#a136">00291</a> <a class="code" href="namespacedg.html#a28">Real</a> <a class="code" href="namespacedg.html#a136">dg::FilteredTurbulence</a>(
00292         <a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ,
00293         <a class="code" href="namespacedg.html#a28">Real</a> fFilterWidth,
00294         <a class="code" href="namespacedg.html#a28">Real</a> fIncrement,
00295         <a class="code" href="namespacedg.html#a28">Real</a> fLacunarity,
00296         <a class="code" href="namespacedg.html#a28">Real</a> fOctaves)
00297 {
00298         <span class="comment">// static variables for caching spectral weights</span>
00299         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacedg.html#a15">UInt</a> uiMaxOctaves = 32;
00300         <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00301         <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00302         <span class="keyword">static</span> <a class="code" href="namespacedg.html#a28">Real</a> fPrevLacunarity = 0;
00303 
00304         <span class="comment">// precompute and store spectral weights</span>
00305         <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00306         {
00307                 <span class="comment">//  compute weight for each frequency</span>
00308                 <span class="keywordflow">for</span>( <a class="code" href="namespacedg.html#a15">UInt</a> i = 0; i &lt; uiMaxOctaves; i++ )
00309                         afExponents[i] = pow( fLacunarity, (<a class="code" href="namespacedg.html#a28">Real</a>)i * -fIncrement );
00310 
00311                 bInitialized = <span class="keyword">true</span>;
00312                 fPrevLacunarity = fLacunarity;
00313         }
00314 
00315         <a class="code" href="namespacedg.html#a15">UInt</a> i = 0;
00316         <a class="code" href="namespacedg.html#a28">Real</a> fTemp, fValue, fRemainder;
00317 
00318         fValue = 0.0;
00319         fTemp = 0.0;
00320 
00321         <span class="comment">// inner loop of spectral construction, where the fractal is built</span>
00322         <span class="keywordflow">for</span> (i = 0; i &lt; fOctaves; i++)
00323         {
00324                 <span class="comment">// calculate the signal contribution</span>
00325                 fTemp = <a class="code" href="namespacedg.html#a165">FilteredGradientNoise</a>(fX, fY, fZ, fFilterWidth) * afExponents[i];
00326 
00327                 <span class="comment">// accumulate the result</span>
00328                 fValue += <a class="code" href="namespacedg.html#a160">FilteredAbs</a>(fTemp, fFilterWidth);
00329 
00330                 <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00331                 fX *= fLacunarity;
00332                 fY *= fLacunarity;
00333                 fZ *= fLacunarity;
00334                 fFilterWidth *= fLacunarity;
00335         }
00336 
00337         <span class="comment">// take care of remainder in "octaves"</span>
00338         fRemainder = fOctaves - (int)fOctaves;
00339         <span class="keywordflow">if</span> ( fRemainder )
00340         {
00341                 <span class="comment">// "i" and spatial freq. are preset in loop above</span>
00342                 fValue += fRemainder * <a class="code" href="namespacedg.html#a165">FilteredGradientNoise</a>(fX, fY, fZ, fFilterWidth) * afExponents[i];
00343 
00344                 <span class="comment">// accumulate the result</span>
00345                 fValue += <a class="code" href="namespacedg.html#a160">FilteredAbs</a>(fTemp, fFilterWidth);
00346         }
00347         <span class="keywordflow">return</span>( fValue );
00348 }
00349 <span class="comment">//******************************************************************************</span>
<a name="l00350"></a><a class="code" href="namespacedg.html#a132">00350</a> <a class="code" href="namespacedg.html#a28">Real</a> <a class="code" href="namespacedg.html#a132">dg::MonoFractal</a>(
00351         <a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ,
00352         <a class="code" href="namespacedg.html#a28">Real</a> fIncrement,
00353         <a class="code" href="namespacedg.html#a28">Real</a> fLacunarity,
00354         <a class="code" href="namespacedg.html#a28">Real</a> fOctaves)
00355 {
00356         <span class="comment">// static variables for caching spectral weights</span>
00357         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacedg.html#a15">UInt</a> uiMaxOctaves = 32;
00358         <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00359         <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00360         <span class="keyword">static</span> <a class="code" href="namespacedg.html#a28">Real</a> fPrevLacunarity = 0;
00361 
00362         <span class="comment">// precompute and store spectral weights</span>
00363         <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00364         {
00365                 <span class="comment">//  compute weight for each frequency</span>
00366                 <span class="keywordflow">for</span>( <a class="code" href="namespacedg.html#a15">UInt</a> i = 0; i &lt; uiMaxOctaves; i++ )
00367                         afExponents[i] = pow( fLacunarity, (<a class="code" href="namespacedg.html#a28">Real</a>)i * -fIncrement );
00368 
00369                 bInitialized = <span class="keyword">true</span>;
00370                 fPrevLacunarity = fLacunarity;
00371         }
00372 
00373 
00374         <a class="code" href="namespacedg.html#a15">UInt</a> i = 0;
00375         <a class="code" href="namespacedg.html#a28">Real</a> fValue, fRemainder;
00376         fValue = 0.0;
00377 
00378         <span class="comment">// inner loop of spectral construction, where the fractal is built</span>
00379         <span class="keywordflow">for</span> ( i = 0; i &lt; fOctaves; i++ )
00380         {
00381                 <span class="comment">// evaluate the basis function to create the spectrum</span>
00382                 fValue += <a class="code" href="namespacedg.html#a128">GradientNoise</a>(fX, fY, fZ) * afExponents[i];
00383 
00384                 <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00385                 fX *= fLacunarity;
00386                 fY *= fLacunarity;
00387                 fZ *= fLacunarity;
00388         }
00389 
00390         <span class="comment">// take care of remainder in "octaves"</span>
00391         fRemainder = fOctaves - (int)fOctaves;
00392         <span class="keywordflow">if</span> ( fRemainder )
00393         {
00394                 <span class="comment">// "i" and spatial freq. are preset in loop above</span>
00395                 fValue += fRemainder * <a class="code" href="namespacedg.html#a128">GradientNoise</a>(fX, fY, fZ) * afExponents[i];
00396         }
00397         <span class="keywordflow">return</span>( fValue );
00398 }
00399 <span class="comment">//*****************************************************************************</span>
<a name="l00400"></a><a class="code" href="namespacedg.html#a133">00400</a> <a class="code" href="namespacedg.html#a28">Real</a> <a class="code" href="namespacedg.html#a133">dg::MultiFractal</a>(
00401         <a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ,
00402         <a class="code" href="namespacedg.html#a28">Real</a> fIncrement,
00403         <a class="code" href="namespacedg.html#a28">Real</a> fLacunarity,
00404         <a class="code" href="namespacedg.html#a28">Real</a> fOctaves)
00405 {
00406         <span class="comment">// static variables for caching spectral weights</span>
00407         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacedg.html#a15">UInt</a> uiMaxOctaves = 32;
00408         <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00409         <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00410         <span class="keyword">static</span> <a class="code" href="namespacedg.html#a28">Real</a> fPrevLacunarity = 0;
00411 
00412         <span class="comment">// precompute and store spectral weights</span>
00413         <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00414         {
00415                 <span class="comment">//  compute weight for each frequency</span>
00416                 <span class="keywordflow">for</span>( <a class="code" href="namespacedg.html#a15">UInt</a> i = 0; i &lt; uiMaxOctaves; i++ )
00417                         afExponents[i] = pow( fLacunarity, (<a class="code" href="namespacedg.html#a28">Real</a>)i * -fIncrement );
00418 
00419                 bInitialized = <span class="keyword">true</span>;
00420                 fPrevLacunarity = fLacunarity;
00421         }
00422 
00423         <a class="code" href="namespacedg.html#a15">UInt</a> i = 0;
00424         <a class="code" href="namespacedg.html#a28">Real</a> fValue, fRemainder;
00425         fValue = 1.0;
00426 
00427         <span class="comment">// inner loop of spectral construction, where the fractal is built</span>
00428         <span class="keywordflow">for</span> ( i = 0; i &lt; fOctaves; i++ )
00429         {
00430                 <span class="comment">// evaluate the basis function to create the spectrum</span>
00431                 fValue *= afExponents[i] * <a class="code" href="namespacedg.html#a128">GradientNoise</a>(fX, fY, fZ) + 1.0f;
00432 
00433                 <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00434                 fX *= fLacunarity;
00435                 fY *= fLacunarity;
00436                 fZ *= fLacunarity;
00437         }
00438 
00439         <span class="comment">// take care of remainder in "octaves"</span>
00440         fRemainder = fOctaves - (int)fOctaves;
00441         <span class="keywordflow">if</span> ( fRemainder )
00442         {
00443                 fValue *= fRemainder * afExponents[i] * <a class="code" href="namespacedg.html#a128">GradientNoise</a>(fX, fY, fZ) + 1.0f;
00444         }
00445         <span class="keywordflow">return</span>( fValue );
00446 }
00447 <span class="comment">//*****************************************************************************</span>
<a name="l00448"></a><a class="code" href="namespacedg.html#a134">00448</a> <a class="code" href="namespacedg.html#a28">Real</a> <a class="code" href="namespacedg.html#a134">dg::HybridMultiFractal</a>(
00449         <a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ,
00450         <a class="code" href="namespacedg.html#a28">Real</a> fIncrement,
00451         <a class="code" href="namespacedg.html#a28">Real</a> fLacunarity,
00452         <a class="code" href="namespacedg.html#a28">Real</a> fOffset,
00453         <a class="code" href="namespacedg.html#a28">Real</a> fGain,
00454         <a class="code" href="namespacedg.html#a28">Real</a> fOctaves)
00455 {
00456         <span class="comment">// static variables for caching spectral weights</span>
00457         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacedg.html#a15">UInt</a> uiMaxOctaves = 32;
00458         <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00459         <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00460         <span class="keyword">static</span> <a class="code" href="namespacedg.html#a28">Real</a> fPrevLacunarity = 0;
00461 
00462         <span class="comment">// precompute and store spectral weights</span>
00463         <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00464         {
00465                 <span class="comment">//  compute weight for each frequency</span>
00466                 <span class="keywordflow">for</span>( <a class="code" href="namespacedg.html#a15">UInt</a> i = 0; i &lt; uiMaxOctaves; i++ )
00467                         afExponents[i] = pow( fLacunarity, (<a class="code" href="namespacedg.html#a28">Real</a>)i * -fIncrement );
00468 
00469                 bInitialized = <span class="keyword">true</span>;
00470                 fPrevLacunarity = fLacunarity;
00471         }
00472 
00473         <a class="code" href="namespacedg.html#a15">UInt</a> i = 0;
00474 
00475         <span class="comment">// get signal for first octave</span>
00476         <a class="code" href="namespacedg.html#a28">Real</a> fSignal = <a class="code" href="namespacedg.html#a128">GradientNoise</a>(fX, fY, fZ);
00477 
00478         <span class="comment">// assign initial values</span>
00479         <a class="code" href="namespacedg.html#a28">Real</a> fResult = fSignal;
00480         <a class="code" href="namespacedg.html#a28">Real</a> fWeight = fGain * fSignal;
00481 
00482         <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00483         fX *= fLacunarity;
00484         fY *= fLacunarity;
00485         fZ *= fLacunarity;
00486 
00487         <span class="comment">// inner loop of spectral construction, where the fractal is built</span>
00488         <span class="keywordflow">for</span> ( i = 0; i &lt; fOctaves; i++ )
00489         {
00490                 <span class="comment">// weight successive contributions by previous signal, clamp [0.0,1.0]</span>
00491                 <span class="keywordflow">if</span>(fWeight &gt; 1.0f)
00492                         fWeight = 1.0f;
00493 
00494                 <span class="comment">// invert and translate (note that "offset" should be ~= 1.0)</span>
00495                 fSignal = (<a class="code" href="namespacedg.html#a128">GradientNoise</a>(fX, fY, fZ) + fOffset) * afExponents[i];
00496 
00497                 <span class="comment">// weight the contribution</span>
00498                 fResult += fSignal * fWeight;
00499 
00500                 <span class="comment">// square the signal, to increase "sharpness" of ridges</span>
00501                 fWeight *= fGain * fSignal;
00502 
00503                 <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00504                 fX *= fLacunarity;
00505                 fY *= fLacunarity;
00506                 fZ *= fLacunarity;
00507         }
00508 
00509         <span class="comment">// take care of remainder in "octaves"</span>
00510         <a class="code" href="namespacedg.html#a28">Real</a> fRemainder = fOctaves - (int)fOctaves;
00511         <span class="keywordflow">if</span> ( fRemainder )
00512         {
00513                 fResult *= fRemainder * afExponents[i] * <a class="code" href="namespacedg.html#a128">GradientNoise</a>(fX, fY, fZ);
00514         }
00515         <span class="keywordflow">return</span> fResult;
00516 }
00517 <span class="comment">//*****************************************************************************</span>
<a name="l00518"></a><a class="code" href="namespacedg.html#a135">00518</a> <a class="code" href="namespacedg.html#a28">Real</a> <a class="code" href="namespacedg.html#a135">dg::RidgedMultiFractal</a>(
00519         <a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ,
00520         <a class="code" href="namespacedg.html#a28">Real</a> fIncrement,
00521         <a class="code" href="namespacedg.html#a28">Real</a> fLacunarity,
00522         <a class="code" href="namespacedg.html#a28">Real</a> fThreshold,
00523         <a class="code" href="namespacedg.html#a28">Real</a> fOffset,
00524         <a class="code" href="namespacedg.html#a28">Real</a> fOctaves)
00525 {
00526         <span class="comment">// static variables for caching spectral weights</span>
00527         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacedg.html#a15">UInt</a> uiMaxOctaves = 32;
00528         <span class="keyword">static</span> <span class="keywordtype">bool</span> bInitialized = <span class="keyword">false</span>;
00529         <span class="keyword">static</span> <span class="keywordtype">double</span> afExponents[uiMaxOctaves];
00530         <span class="keyword">static</span> <a class="code" href="namespacedg.html#a28">Real</a> fPrevLacunarity = 0;
00531 
00532         <span class="comment">// precompute and store spectral weights</span>
00533         <span class="keywordflow">if</span>(!bInitialized || fPrevLacunarity != fLacunarity)
00534         {
00535                 <span class="comment">//  compute weight for each frequency</span>
00536                 <span class="keywordflow">for</span>( <a class="code" href="namespacedg.html#a15">UInt</a> i = 0; i &lt; uiMaxOctaves; i++ )
00537                         afExponents[i] = pow( fLacunarity, (<a class="code" href="namespacedg.html#a28">Real</a>)i * -fIncrement );
00538 
00539                 bInitialized = <span class="keyword">true</span>;
00540                 fPrevLacunarity = fLacunarity;
00541         }
00542 
00543         <a class="code" href="namespacedg.html#a15">UInt</a> i = 0;
00544 
00545         <span class="comment">// get absolute value of signal for first octave (this creates the ridges)</span>
00546         <a class="code" href="namespacedg.html#a28">Real</a> fSignal = <a class="code" href="namespacedg.html#a90">Abs</a>( <a class="code" href="namespacedg.html#a128">GradientNoise</a>(fX, fY, fZ) );
00547 
00548         <span class="comment">// invert and translate (note that "offset" should be ~= 1.0)</span>
00549         fSignal = fOffset - fSignal;
00550 
00551         <span class="comment">// square the signal, to increase "sharpness" of ridges</span>
00552         fSignal *= fSignal;
00553 
00554         <span class="comment">// assign initial values</span>
00555         <a class="code" href="namespacedg.html#a28">Real</a> fResult = fSignal;
00556         <a class="code" href="namespacedg.html#a28">Real</a> fWeight = 1.0;
00557 
00558         <span class="comment">// inner loop of spectral construction, where the fractal is built</span>
00559         <span class="keywordflow">for</span> ( i = 0; i &lt; fOctaves; i++ )
00560         {
00561                 <span class="comment">// multipy in the lacunarity to create the gaps between octaves</span>
00562                 fX *= fLacunarity;
00563                 fY *= fLacunarity;
00564                 fZ *= fLacunarity;
00565 
00566                 <span class="comment">// weight successive contributions by previous signal, clamp [0.0,1.0]</span>
00567                 fWeight = <a class="code" href="namespacedg.html#a62">Clamp</a>( fSignal * fThreshold, 0.0, 1.0 );
00568 
00569                 <span class="comment">// get absolute value of signal (this creates the ridges)</span>
00570                 fSignal = <a class="code" href="namespacedg.html#a90">Abs</a>( <a class="code" href="namespacedg.html#a128">GradientNoise</a>(fX, fY, fZ ));
00571 
00572                 <span class="comment">// invert and translate (note that "offset" should be ~= 1.0)</span>
00573                 fSignal = fOffset - fSignal;
00574 
00575                 <span class="comment">// square the signal, to increase "sharpness" of ridges</span>
00576                 fSignal *= fSignal;
00577 
00578                 <span class="comment">// weight the contribution</span>
00579                 fSignal *= fWeight;
00580 
00581                 <span class="comment">// accumulate the result</span>
00582                 fResult += fSignal * afExponents[i];
00583 
00584         }
00585         <span class="keywordflow">return</span> fResult;
00586 }
00587 <span class="comment">//******************************************************************************</span>
<a name="l00588"></a><a class="code" href="namespacedg.html#a72">00588</a> <a class="code" href="namespacedg.html#a28">Real</a> <a class="code" href="namespacedg.html#a72">dg::Quadric</a>(<a class="code" href="namespacedg.html#a28">Real</a> fA, <a class="code" href="namespacedg.html#a28">Real</a> fB, <a class="code" href="namespacedg.html#a28">Real</a> fC)
00589 {
00590         <a class="code" href="namespacedg.html#a28">Real</a> fT = 0.0;
00591         <a class="code" href="namespacedg.html#a28">Real</a> fDet = fB*fB - 4.0*fA*fC;
00592         fA *= 2.0;
00593         <span class="keywordflow">if</span> (fDet &gt; 0.0)
00594         {
00595                 fDet = sqrt(fDet);
00596                 fT = (fB - fDet)/fA;
00597                 <span class="keywordflow">if</span> (fT &gt; 0.0)
00598                 {
00599                         <span class="keywordflow">return</span> fT;
00600                 }
00601                 <span class="keywordflow">else</span>
00602                 {
00603                         fT = (fB + fDet)/fA;
00604                         <span class="keywordflow">return</span> fT;
00605                 }
00606         }
00607         <span class="keywordflow">else</span>
00608         {
00609            fT = -1.0;
00610         }
00611         <span class="keywordflow">return</span> fT;
00612 }
00613 <span class="comment">//******************************************************************************</span>
<a name="l00614"></a><a class="code" href="namespacedg.html#a138">00614</a> <a class="code" href="namespacedg.html#a28">Real</a> <a class="code" href="namespacedg.html#a138">dg::VoronoiNoise</a>(
00615         <a class="code" href="namespacedg.html#a28">Real</a> fX, <a class="code" href="namespacedg.html#a28">Real</a> fY, <a class="code" href="namespacedg.html#a28">Real</a> fZ,
00616         <a class="code" href="namespacedg.html#a28">Real</a> fJitter,
00617         <a class="code" href="namespacedg.html#a28">Real</a>&amp; rfOX, <a class="code" href="namespacedg.html#a28">Real</a>&amp; rfOY, <a class="code" href="namespacedg.html#a28">Real</a>&amp; rfOZ)
00618 {
00619         <a class="code" href="namespacedg.html#a28">Real</a> fCX = <a class="code" href="namespacedg.html#a94">Floor</a>(fX) + 0.5;
00620         <a class="code" href="namespacedg.html#a28">Real</a> fCY = <a class="code" href="namespacedg.html#a94">Floor</a>(fY) + 0.5;
00621         <a class="code" href="namespacedg.html#a28">Real</a> fCZ = <a class="code" href="namespacedg.html#a94">Floor</a>(fZ) + 0.5;
00622 
00623         <a class="code" href="namespacedg.html#a28">Real</a> f1 = 1000;
00624         <a class="code" href="namespacedg.html#a28">Real</a> i, j, k;
00625         <span class="keywordflow">for</span> (i = -1;  i &lt;= 1;  i += 1)
00626         {
00627                 <span class="keywordflow">for</span> (j = -1;  j &lt;= 1;  j += 1)
00628                 {
00629                         <span class="keywordflow">for</span> (k = -1;  k &lt;= 1;  k += 1)
00630                         {
00631                                 <a class="code" href="namespacedg.html#a28">Real</a> fTX = fCX + i;
00632                                 <a class="code" href="namespacedg.html#a28">Real</a> fTY = fCY + j;
00633                                 <a class="code" href="namespacedg.html#a28">Real</a> fTZ = fCZ + k;
00634 
00635                                 <a class="code" href="namespacedg.html#a28">Real</a> fNoise = <a class="code" href="namespacedg.html#a127">CellNoise</a>(fTX, fTY, fTZ);
00636 
00637                                 <a class="code" href="namespacedg.html#a28">Real</a> fPX = fTX + fJitter * fNoise - 0.5;
00638                                 <a class="code" href="namespacedg.html#a28">Real</a> fPY = fTY + fJitter * fNoise - 0.5;
00639                                 <a class="code" href="namespacedg.html#a28">Real</a> fPZ = fTZ + fJitter * fNoise - 0.5;
00640 
00641                                 <a class="code" href="namespacedg.html#a28">Real</a> fDX = fPX - fX;
00642                                 <a class="code" href="namespacedg.html#a28">Real</a> fDY = fPY - fY;
00643                                 <a class="code" href="namespacedg.html#a28">Real</a> fDZ = fPZ - fZ;
00644 
00645                                 <a class="code" href="namespacedg.html#a28">Real</a> fDistSqr = fDX*fDX + fDY*fDY + fDZ*fDZ;
00646 
00647                                 <span class="keywordflow">if</span>(fDistSqr &lt; f1)
00648                                 {
00649                                         f1 = fDistSqr;
00650                                         rfOX = fPX;
00651                                         rfOY = fPY;
00652                                         rfOZ = fPZ;
00653                                 }
00654                         }
00655                 }
00656         }
00657         <span class="keywordflow">return</span> sqrt(f1);
00658 }
</pre></div>		<div class="footer" width="100%">
		<hr>
			<a href="http://lyon-smith.org/">&copy; Derek Gerstmann - NCCA - Bournemouth University - 2004</a>
		</div>
		<br>
	</body>
</html>
